<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale: 1.0, maximum-scale: 1.0, user-scalable: no">
    <title>Kong (Treasure Hunt) Slot Machine</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Andada+Pro:ital,wght@0,400..840;1,400..840&family=Chakra+Petch:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&family=Noto+Serif:ital,wght@0,100..900;1,100..900&family=Victor+Mono:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jockey+One&family=Russo+One&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="service.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #2c2c2c;
            touch-action: manipulation;
            /* font-family: 'Victor Mono', monospace; */
            font-optical-sizing: auto;
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'aldo';
            src: url('aldo_the_apache') format('truetype');
        }
        .russo-one-regular {
            font-family: "Russo One", sans-serif;
            font-weight: 400;
            font-style: normal;
        }

    .text-container {
        perspective: 500px;
        display: inline-block;
        transform-style: preserve-3d;

        /* Subtle 3D shadow box */
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
        border-radius: 6px;
        background: white; /* Optional, for contrast */
        padding: 5px;
    }


.gradient-text {
    font-size: 4rem;
    font-weight: 900;
    letter-spacing: 2px;
    position: relative;
    display: inline-block;
    text-align: center;

    /* Smoother gradient with gradual color transitions */
    background: linear-gradient(to right,
        #cc6600 0%,       /* vivid yellow */
        #003f5c 25%,      /* lighter orange */
        #ff9933 50%,      /* warm orange */
        #cc6600 75%,      /* darker orange-brown */
        #ff9933 100%      /* dark blue-teal */
    );
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;

    /* Keep your 3D shadow effect */
    text-shadow:
        1px 1px #F08000,
        2px 2px #884400,
        3px 3px #663300,
        3px 3px #663300,
        3px 3px #663300,
        4px 4px #442200,
        5px 5px #221100,
        6px 6px rgba(0, 0, 0, 0.8),
        8px 8px rgba(0, 0, 0, 0.6),
        10px 10px rgba(0, 0, 0, 0.4);
}


.gradient-text2 {
    font-size: 4rem;
    font-weight: 900;
    letter-spacing: 2px;
    position: relative;
    display: inline-block;
    text-align: center;

    /* Smoother gradient with gradual color transitions */
    background: linear-gradient(to right,
        #b87e3c 0%,       /* vivid yellow */
        #003f5c 25%,      /* lighter orange */
        #ff9933 50%,      /* warm orange */
        #cc6600 75%,      /* darker orange-brown */
        #ff9933 100%      /* dark blue-teal */
    );
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;

    /* Keep your 3D shadow effect */
    text-shadow:
        1px 1px gold,
        2px 2px #884400,
        3px 3px #663300,
        3px 3px #F08000,
        3px 3px #F08000,
        4px 4px #F08000,
        5px 5px #221100,
        6px 6px rgba(0, 0, 0, 0.8),
        8px 8px rgba(0, 0, 0, 0.6),
        10px 10px rgba(0, 0, 0, 0.4);
}

 .text-3d {
        color: #ffff00;
        font-weight: 900;
        font-size: clamp(3rem, 8vw, 6rem);
        letter-spacing: 0.05em;
        margin-bottom: 2rem;
        text-shadow: 
            /* Yellow top layer */
            0px 0px 0px #ffff00,
            
            /* Orange middle layers */
            0px 1px 0px #ff8c00,
            0px 2px 0px #ff7f00,
            0px 3px 0px #ff6600,
            0px 4px 0px #ff5500,
            
            /* Brown bottom layers */
            0px 5px 0px #cc6600,
            0px 6px 0px #b85500,
            0px 7px 0px #a04400,
            0px 8px 0px #8b3a00,
            0px 9px 0px #773300,
            0px 10px 0px #662b00,
            0px 11px 0px #552200,
            0px 12px 0px #441a00,
            
            /* Dark outline and depth */
            1px 1px 0px #331100,
            -1px 1px 0px #331100,
            1px -1px 0px #331100,
            -1px -1px 0px #331100,
            
            /* Shadow for depth */
            0px 15px 10px rgba(0, 0, 0, 0.3),
            0px 20px 20px rgba(0, 0, 0, 0.2),
            0px 25px 30px rgba(0, 0, 0, 0.1);
        
        animation: float 4s ease-in-out infinite;
    }



        #game-container {
            width: 100%;
            height: 100vh;
            max-height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: 'aldo', sans-serif;
        }
        .game-canvas-container {
            flex: 1;
            position: relative;
            height: 100%;
            width: 100%;
            margin: auto;
            overflow: hidden;
            z-index: 888;
        }
        .game-controls {
            margin: 0px !important;
            padding: 0px !important;
            width: 100%;
            background-image: url('background_cp.png');
            background-size: cover;
            z-index: 1000;
            bottom: 0 !important;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .spin-button, .autoplay-button {
            cursor: pointer;
            width: 100%;
            text-align: center;
            padding: 12px;
        }
        /* Responsive adjustments */
        @media (max-height: 600px) {
            .game-controls {
                padding: 5px;
            }
            .control-group {
                gap: 5px;
            }
            .input-group {
                margin-bottom: 5px;
            }
        }
        /* Prevent text selection */
        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        /* Allow input in number fields */
        input[type="number"] {
            -webkit-user-select: auto;
            -moz-user-select: auto;
            -ms-user-select: auto;
            user-select: auto;
        }
        #jdb_overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            z-index: 2002;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #kong_overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('kong_bcg4.png');
            background-size: cover;
            background-repeat: repeat;
            background-color: black;
            z-index: 2001;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        /* Stake button and overlay styles */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 1);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .overlay-content {
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            padding: 20px;
            margin-top: 100px;
        }
        #inactivityOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 3000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: white;
        }
        #inactivityOverlay h2 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            color: #ff9900;
        }
        #inactivityOverlay p {
            font-size: 1.2rem;
            margin-bottom: 2rem;
        }
        #reloadButton {
            background: linear-gradient(to bottom, #ff9900, #ff6600);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        #reloadButton:hover {
            background: linear-gradient(to bottom, #ffaa33, #ff7722);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        .overlay-content-stake {
            border-radius: 12px;
            width: 100%;
            max-width: 400px;
            padding: 20px;
            margin-top: 100px;
        }
        .overlay-header {
            color: #e4d594;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: bold;
        }
        .options-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .option-button {
            background: linear-gradient(to bottom, #282727, #272525);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 5px 0;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .option-button:hover, .option-button.selected {
            background-color: #25282b;
            box-shadow: 
                inset 0 0 0 1px rgba(0, 0, 0, 0.15),
                0 0 0 1px rgba(0, 0, 0, 0.15),
                inset 0 0 0.875rem #FCEAAC,
                0 0 0.875rem #FCEAAC;
        }
        .overlay-footer {
            background-color: black;
            width: inherit;
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding-bottom: 50px;
            bottom: 0;
        }
        .overlay-footer-stake {
            margin-top: 20px;
            padding-bottom: 50px;
            bottom: 0;
            position: absolute;
        }
        .overlay-footer button {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
        }
        .cancel-button {
            background-color: #333;
            color: white;
        }
        .confirm-button {
            background-color: #333;
            box-shadow: 0 0 4px #e4d594;
            color: white;
        }
        .divider-container {
            color: #e4d594;
        }
        .divider {
            height: 2px;
            background-color: #e4d594;
            width: 30vw;
        }
        .divider-text {
            margin: 0 10px;
        }
        .divider-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            margin: 16px 0;
        }
        .check-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-left: 4px;
            position: relative;
        }
        .check-icon:before {
            content: '';
            position: absolute;
            width: 8px;
            height: 12px;
            border-right: 2px solid white;
            border-bottom: 2px solid white;
            transform: rotate(45deg);
            top: 0;
            left: 4px;
        }
        
        .victor-mono {
            font-family: "Victor Mono", monospace;
            font-optical-sizing: auto;
            font-weight: normal;
            font-style: normal;
        }

        /* Settings overlay styles */
        .sound-option {
            color: white;
        }
        .icon-container {
            font-size: 1.5rem;
            display: inline-block;
            width: 30px;
            text-align: center;
        }
        .loader-container {
            height: 10px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 12px;
        }
        .loader-bar {
            height: 100%;
            width: 0;
            transition: width 0.3s ease;
        }
        .glowing-button {
            position: absolute; /* Ensure ::after is positioned relative to this */
            bottom: 9%;
            padding: 6px 50px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            border-radius: 12px;
            border-width: 5px;
            border-style: solid;
            border-color: #c09c0e;
            background-color: #fada60;
            font-weight: bold;
            text-shadow: 
                -1px -1px 0 orange,  
                1px -1px 0 orange,
                -1px  1px 0 orange,
                1px  1px 0 orange;
            overflow: hidden; /* Prevents the light effect from overflowing */
        }

        /* Light reflection effect */
        .glowing-button::after {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 200%; /* Reduce width to prevent excessive overflow */
            height: 100%;
            background: linear-gradient(
                100deg,
                rgba(255, 255, 255, 0) 40%,
                rgba(255, 255, 255, 0.4) 50%,
                rgba(255, 255, 255, 0) 60%
            );
            animation: light-sweep 2s infinite linear;
        }

        @keyframes light-sweep {
            0% {
                left: -100%;
            }
            100% {
                left: 100%;
            }
        }

        /* Free spins indicator */
        .free-spins-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(192, 156, 14, 0.8);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 1.0rem;
            font-weight: bold;
            z-index: 100;
            display: none;
        }

        /* Win message */
        .win-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #fada60;
            padding: 15px 30px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            animation: bounce 1s infinite;
            z-index: 100;
            display: none;
        }
        
        /* Win group overlay */
        .win-group-display {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #ffc107;
            padding: 10px 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            z-index: 100;
            display: none;
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.6);
            text-shadow: 0 0 5px rgba(255, 193, 7, 0.6);
        }
        
        .win-flash {
            animation: flash-animation 1s;
        }
        
        @keyframes flash-animation {
            0%, 50%, 100% {
                opacity: 1;
                transform: scale(1) translateX(-50%);
            }
            25%, 75% {
                opacity: 0.7;
                transform: scale(1.1) translateX(-45%);
            }
        }

        .mobile-wrapper {
            max-width: 100vw;
            max-height: 100vh;
        }
        .autoplay-button, .stake-button{
            height: 65px;
            width: 65px;
        }
        .spin-img{
            height: 60px;
            width: 60px;
        }
        .spin-button{
            height: 85px;
            width: 85px;
        }
        .autospininner-img{
            height: 35px;
            width: 35px;
        }
        .autospininnerimgstop{
            height: 25px;
            width: 25px;
        }
        .totalbetinner-img{
            height: 24px;
        }
        .current-stake{
            font-size: 1.1rem;
            color: #f6d64e;
        }
        #playground{
            height: 40vh;
        }
        .fs-text-image{
            max-height: 23px;
        }
        #remaining_fs_holder, #total_fs_holder{
            color: #8cc904;
            font-size: 2.0rem;
            font-weight: bold;
        }

        @media screen and (min-width: 900px) {
            .sunburst-container {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 80vw;
                max-width: 600px;
                height: 80vw;
                max-height: 600px;
                z-index: 10; /* Higher than coins */
                display: flex;
                align-items: center;
                justify-content: center;
                overflow: visible;
                pointer-events: none;
            }
            #jdb_overlay {
                max-width: 320px;
                max-height: 5100px;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                left: 50%;
                transform: translate(-50%, -0%);
                background-color: black;
                z-index: 2002;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }
            #kong_overlay {
                max-width: 320px;
                max-height: 5100px;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                left: 50%;
                transform: translate(-50%, -0%);
                background-image: url('kong_bcg5.png');
                background-size: contain;
                background-repeat: no-repeat;
                background-color: black;
                z-index: 2001;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }
            .overlay {
                position: absolute;
                max-width: 320px;
                max-height: 5100px;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                left: 50%;
                transform: translate(-50%, -0%);
                background-color: rgba(0, 0, 0, 1);
                z-index: 2000;
                display: none;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }
            #playground{
                max-height: 200px;
                width: 100%;
            }
            .mobile-wrapper {
                max-width: 320px;
                max-height: 490px;
            }
            .current-stake{
                font-size: 1.0rem;
                color: #f6d64e;
            }
            .fs-text-image{
                max-height: 20px;
            }
            #remaining_fs_holder, #total_fs_holder{
                color: #8cc904;
                font-size: 1.5rem;
                font-weight: bold;
            }
        }

        .btn-gold {
            background-color: #b8860b;
            color: white;
            border: none;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        .btn-gold:hover {
            background-color: #a67c00;
            color: white;
        }

        #winOverlay{
            position: fixed;
            width: 100%;
            min-height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #closeBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 8px;
            z-index: 20;
        }

        .win-content {
            position: relative;
            text-align: center;
            z-index: 15;
        }

        /* Rotating sunburst effect */
        .sunburst-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vw;
            max-width: 600px;
            height: 80vw;
            max-height: 600px;
            z-index: 10; /* Higher than coins */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible;
            pointer-events: none;
        }

        .sunburst {
            width: 100%;
            height: 100%;
            background-image: url('https://hebbkx1anhila5yf.public.blob.vercel-storage.com/BigWin_FX-pnFZvgsE0rjtfTiTODDEY1oM6AHQJ4.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            animation: rotate 10s linear infinite;
        }

        /* Colored overlays for different win levels */
        .big-win-color {
            filter: none;
        }

        .mega-win-color {
            filter: none; /* Original gold/yellow color */
        }

        .ultra-win-color {
            filter: none;
        }

        @keyframes rotate {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .win-text {
            font-size: calc(2rem + 2vw);
            font-weight: bold;
            margin-bottom: 16px;
            text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
            animation: text-flicker 2s infinite;
            transition: color 0.5s, transform 0.5s;
            position: relative;
            z-index: 20;
        }

        .counter-text {
            font-size: calc(1.2rem + 2vw);
            font-weight: bold;
            color: #a67c00;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.7), 0 0 20px rgba(255, 215, 0, 0.5);
            animation: pulse 1.5s infinite;
            position: relative;
            z-index: 20;
        }

        #coinsContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: 5; /* Lower than sunburst */
        }

        .coin {
            position: absolute;
            filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.7));
            transition: transform 0.05s ease-out;
            z-index: 5; /* Lower than sunburst */
        }

        /* Win level styles */
        .big-win {
            color: #ffd700;
        }

        .mega-win {
            color: #ffd700;
        }

        .ultra-win {
            color: #ffd700;
        }

        @keyframes text-flicker {
            0%, 100% {
                opacity: 1;
                text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
            }
            50% {
                opacity: 0.9;
                text-shadow: 0 0 15px currentColor, 0 0 25px currentColor;
            }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        @keyframes scale-in {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .scale-in {
            animation: scale-in 0.5s forwards;
        }

        /* Game info overlay */
        #gameinfo_overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            z-index: 2002;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: auto;
            display: none;
        }

        /* Features overlay */
        #featuresOverlay {
            display: none;
            z-index: 9999;
            position: absolute;
            height: 100%;
            width: 100%;
            background-color: rgb(0,0,0,0.8);
        }

        /* Device overlay */
        #device_overlay {
            display: none;
        }

        /* Free spins overlay */
        #freespinsoverlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            background-color: rgba(0, 0, 0, 0.8);
            height: 100%;
            width: 100%;
            z-index: 999999;
        }

        /* Canvas styles */
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>


<style>
        .coins-container {
            position: fixed;
            bottom: 0;
            z-index: 10;
            min-height: 200px;
            width: 100%;
            background-image: url('coins_at_bottom.png');
            background-repeat: no-repeat;
            background-position: center bottom;
            background-size: cover;
        }

        .ember-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .falling-coins-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        .ember {
            position: absolute;
            background-image: url('ember.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            width: 12px;
            height: 16px;
            opacity: 0;
            animation: rise linear forwards;
        }

        .ember.front {
            z-index: 15;
        }

        .falling-coin {
            position: absolute;
            width: 25px;
            height: 25px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0;
            animation: fall linear forwards;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        .falling-coin.front {
            background-image: url('coin_frontside.png');
        }

        .falling-coin.side {
            background-image: url('side_of_the_coin.png');
        }

        .falling-coin.small {
            width: 24px;
            height: 24px;
        }

        .falling-coin.large {
            width: 350px;
            height: 35px;
        }

        @keyframes fall {
            0% {
                transform: translateY(-50px) translateX(0) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(calc(100vh + 50px)) translateX(var(--drift)) rotate(var(--rotation));
                opacity: 0;
            }
        }

        @keyframes rise {
            0% {
                transform: translateY(0) translateX(0) scale(0.3) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.8;
                transform: translateY(var(--y-10)) translateX(var(--x-10)) scale(0.6) rotate(var(--rotation));
            }
            50% {
                opacity: 1;
                transform: translateY(var(--y-50)) translateX(var(--x-50)) scale(1) rotate(var(--rotation));
                z-index: 15;
            }
            80% {
                opacity: 0.7;
                transform: translateY(var(--y-80)) translateX(var(--x-80)) scale(0.8) rotate(var(--rotation));
            }
            100% {
                opacity: 0;
                transform: translateY(var(--y-100)) translateX(var(--x-100)) scale(0.2) rotate(var(--rotation));
            }
        }

        /* Particle variations */
        .ember.small {
            width: 12px;
            height: 12px;
        }

        .ember.medium {
            width: 12px;
            height: 13px;
        }

        .ember.large {
            width: 12px;
            height: 12px;
        }
</style>

<style>
.hidden-fade {
    display: none;
    opacity: 0;
    transform: translateY(-50px);
}

.fade-from-top {
    transition: opacity 1s ease-out, transform 1s ease-out;
}

.fade-from-top.show {
    display: block;
    opacity: 1;
    transform: translateY(0);
}
</style>


</head>
<body class="w-100">
<div style="background-image: url('page_bcg.png'); background-size: cover; height: 100vh; padding: 0 !important;">
    <div style="z-index: 3; position: absolute;" class="mt-2">
        <button id="featuresButton" class="btn btn-warning mt-5 mb-2 mx-3">
            Feature
        </button>
    </div>
    <div id="featuresOverlay">
       <div style="height: 100%; width: 100%; font-weight: bold;" class="d-flex justify-content-center align-items-center">
            <div class="mx-auto">
                <div class="mx-auto">
                    <button onclick="setDemoFeature('big spin')" class="btn btn-warning btn-lg my-2 mb-2 mx-3">
                        Feature 1
                    </button>
                </div>
                <div class="mx-auto">
                    <button onclick="setDemoFeature('big win')" class="btn btn-warning btn-lg my-2 mx-3">
                        Feature 2
                    </button>
                </div>
                <div class="mx-auto">
                    <button onclick="setDemoFeature('free spins')" class="btn btn-warning btn-lg my-2 mb-2 mx-3">
                        Feature 3
                    </button>
                </div>
            </div>
       </div>
    </div>

    <div class="mobile-wrapper mx-auto">

        <div id="gameinfo_overlay" class="overlay" style="max-height: 100vh !important;overflow-y: scroll;overflow-x: hidden;">
            <div class="divider-container">
                <div class="divider-wrapper">
                    <div class="divider-text h3">GAME RULE</div>
                </div>
            </div>
            <div class="d-flex justify-content-center align-items-center">
                <div style="width: 90%;background-color: #e4d594;height: 5px;"></div>
            </div>
            <div class="" style="color: white;">
                <div style="border: 1px;border-color: #e4d594;font-size: 1.0rem;border-style: solid;" class="py-4 mx-3 d-flex justify-content-center align-items-around my-3">
                    <div class="px-2">
                        <span style="color: #e4d594;"> Denomination:</span> 0.01
                    </div>
                    <div class="px-2">
                        <span style="color: #e4d594;">Bet Multiplier:</span> 1
                    </div>
                </div>
                <div class="row px-3">
                    <div class="col-lg-3 col-md-12 col-sm-12 text-center px-4" style="font-weight: bold;">
                        <img src="wild.png"style="max-width: 130px;" alt="">
                        <div class="h3">WILD</div>
                    </div>
                    <div class="col-lg-9 col-md-12 col-lg-12" style="font-weight: bold;">
                        ONLY APPEARS ON REELS 2,3,4 AND 5.
                        <br>
                        <br>
                        <div class="d-flex justify-content-start align-items-center">
                            SUBSTITUTES FOR ALL SYMBOLS EXCEPT <img style="width: 40px;height: auto;" src="scatter.png" alt="">
                        </div>
                    </div>
                </div>
    
    
                <div class="row px-3 my-3">
                    <div class="col-lg-3 col-md-12 col-sm-12 text-center px-4 mb-3">
                        <img src="scatter.png"style="max-width: 130px;" alt="">
                        <div class="h3">FREE SPIN BONUS</div>
                    </div>
                    <div class="col-lg-9 col-md-12 col-lg-12" style="font-weight: bold;">
                        APPEARS ON ALL REELS
                        <br>
                        <div class="">
                            IF ATLEAST ONE <img style="width: 40px;height: auto;" src="scatter.png" alt=""> APPEARS ON ALL REELS FREE SPIN BONUS WITH 13 FREE SPINS AND A BONUS MULTIPLIER WILL BE TRIGGERED 
                        </div>
    
                        <div class="mt-4">
                            <div class="my-1">
                                5 <img style="width: 40px;height: auto;" class="px-1" src="scatter.png" alt=""> AWARDS 3X BONUS MULTIPLIER
                            </div>
                            <div class="my-1">
                                6 <img style="width: 40px;height: auto;" class="px-1" src="scatter.png" alt=""> AWARDS 6X BONUS MULTIPLIER
                            </div>
                            <div class="my-1">
                                7 <img style="width: 40px;height: auto;" class="px-1" src="scatter.png" alt=""> AWARDS 12X BONUS MULTIPLIER
                            </div>
                            <div class="my-1">
                                8 <img style="width: 40px;height: auto;" class="px-1" src="scatter.png" alt=""> AWARDS 24X BONUS MULTIPLIER
                            </div>
                            <div class="my-1">
                                9 <img style="width: 40px;height: auto;" class="px-1" src="scatter.png" alt=""> AWARDS 36X BONUS MULTIPLIER
                            </div>
                            <div class="my-1">
                                10 <img style="width: 40px;height: auto;" class="px-1" src="scatter.png" alt=""> AWARDS 72X BONUS MULTIPLIER
                            </div>
                        </div>
                    </div>
                </div>
    
                <div class="divider-container">
                    <div class="divider-wrapper">
                        <div class="divider-text h2" style="font-weight: bold;" >PAYTABLE</div>
                    </div>
                </div>
    
                <div class="d-flex justify-content-center align-items-center">
                    <div style="width: 90%;background-color: white;height: 2px;"></div>
                </div>
    
                <div class="row my-4" style="font-size: 1.1rem;font-weight: bold;">
                    <div class="my-3 col-12 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="treasurechest.png" style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 250
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 100
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 40
                            </div>
                        </div>
                    </div>
                    <div class="col-12 my-3 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="explorer.png"style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 200
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 80
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 30
                            </div>
                        </div>
                    </div>
                    <div class="col-12 my-3 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="compass.png"style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 175
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 60
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 25
                            </div>
                        </div>
                    </div>
                </div>
                <div class="row my-4" style="font-size: 1.1rem;font-weight: bold;">
                    <div class="my-3 col-12 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="binoculars.png"style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 150
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 50
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 20
                            </div>
                        </div>
                    </div>
                    <div class="my-3 col-12 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="a.png"style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 100
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 20
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 10
                            </div>
                        </div>
                    </div>
                    <div class="my-3 col-12 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="k.png"style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 90
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 15
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 8
                            </div>
                        </div>
                    </div>
                </div>
                <div class="row my-4" style="font-size: 1.1rem;font-weight: bold;">
                    <div class="my-3 col-12 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="q.png"style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 80
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 12
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 6
                            </div>
                        </div>
                    </div>
                    <div class="my-3 col-12 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="j.png"style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 70
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 10
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 5
                            </div>
                        </div>
                    </div>
                    <div class="my-3 col-12 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2" style="visibility: hidden;">
                        
                    </div>
                </div>
    
                <div style="font-size: 1.0rem;" class="text-center">
                    <div class="my-1">
                        ALL WINS PAY LEFTMOST TO RIGHT, EXCEPT <img src="scatter.png" style="max-width: 40px;" alt="">
                    </div>
                    <div class="my-1">
                        PAYTABLE WINS ARE SHOWN FOR BET MULTIPLIER X1.
                    </div>
                    <div class="my-1">
                        PAYTABLE WINS ARE SHOWN IN CREDITS
                    </div>
                </div>
    
                <div class="divider-container mt-5">
                    <div class="divider-wrapper">
                        <div class="divider-text h2" style="font-weight: bold;">FREE SPIN BONUS</div>
                    </div>
                </div>
    
                <div class="d-flex justify-content-center align-items-center">
                    <div style="width: 90%;background-color: white;height: 2px;"></div>
                </div>
                
    
                <div style="font-size: 1.0rem;border: 1px;border-style: solid;border-color: white;" class="px-4 my-3 mx-3 py-2">
                    IF AT LEAST ONE <img style="max-width: 40px;" src="scatter.png" alt=""> APPEARS ON ALL REELS, ADDITIONAL 13 FREE SPINS ARE AWARDED, TO A MAXIMUM OF 100 FREE SPINS IN A SINGLE BOUGHT GAME. RETRIGGER OF FREE SPIN BONUS WILL NOT CHANGE THE BONUS MULTIPLIER OF THE FREE SPIN BONUS. 
                    <br>
                    DURING FREE SPIN BONUS, THE WINS ARE MULTIPLIED BY THE BONUS MULTIPLIER AND ADDED TO THE WIN METER
                </div>
    
                <div style="border: 1px;border-color: #e4d594;font-size: 1.0rem;border-style: solid;" class="py-4 mx-3 d-flex justify-content-center align-items-around my-3">
                    <div class="px-2">
                        <span style="color: #e4d594;"> Denomination:</span> 0.01
                    </div>
                    <div class="px-2">
                        <span style="color: #e4d594;">Bet Multiplier:</span> 1
                    </div>
                </div>

                <div class="row px-3">
                    <div class="col-lg-3 col-md-12 col-sm-12 text-center px-4" style="font-weight: bold;">
                        <img src="wild.png"style="max-width: 130px;" alt="">
                        <div class="h3">WILD</div>
                    </div>
                    <div class="col-lg-9 col-md-12 col-lg-12" style="font-weight: bold;">
                        ONLY APPEARS ON REELS 2,3,4 AND 5.
                        <br>
                        <br>
                        <div class="d-flex justify-content-start align-items-center">
                            SUBSTITUTES FOR ALL SYMBOLS EXCEPT <img style="width: 40px;height: auto;" src="scatter.png" alt="">
                        </div>
                    </div>
                </div>

                <div class="row px-3 my-3">
                    <div class="col-lg-3 col-md-12 col-sm-12 text-center px-4 mb-3">
                        <img src="scatter.png"style="max-width: 130px;" alt="">
                        <div class="h3">FREE SPIN BONUS</div>
                    </div>
                    <div class="col-lg-9 col-md-12 col-lg-12" style="font-weight: bold;">
                        APPEARS ON ALL REELS
                    </div>
                </div>
    
    
                <div class="row my-4" style="font-size: 1.1rem;font-weight: bold;">
                    <div class="my-3 col-12 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="treasurechest.png"style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 250
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 100
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 40
                            </div>
                        </div>
                    </div>
                    <div class="col-12 my-3 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="explorer.png"style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 200
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 80
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 30
                            </div>
                        </div>
                    </div>
                    <div class="col-12 my-3 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="compass.png"style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 175
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 60
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 25
                            </div>
                        </div>
                    </div>
                </div>
                <div class="row my-4" style="font-size: 1.1rem;font-weight: bold;">
                    <div class="my-3 col-12 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="binoculars.png"style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 150
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 50
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 20
                            </div>
                        </div>
                    </div>
                    <div class="my-3 col-12 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="a.png"style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 100
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 20
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 10
                            </div>
                        </div>
                    </div>
                    <div class="my-3 col-12 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="k.png"style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 90
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 15
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 8
                            </div>
                        </div>
                    </div>
                </div>
                <div class="row my-4" style="font-size: 1.1rem;font-weight: bold;">
                    <div class="my-3 col-12 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="q.png"style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 80
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 12
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 6
                            </div>
                        </div>
                    </div>
                    <div class="my-3 col-12 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2">
                        <img src="j.png"style="max-width: 130px;" alt="">
                        <div class="px-4">
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">5 - </span> 70
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">4 - </span> 10
                            </div>
                            <div class="my-1">
                                <span style="color: #e4d594;font-weight: bold;">3 - </span> 5
                            </div>
                        </div>
                    </div>
                    <div class="my-3 col-12 col-lg-4 col-dm-4 col-sm-12 d-flex justify-content-center align-items-center align-items-center mx-2" style="visibility: hidden;">
                        
                    </div>
                </div>
    
                <div style="font-size: 1.0rem;" class="text-center">
                    <div class="my-1">
                        ALL WINS PAY LEFTMOST TO RIGHT, EXCEPT <img src="scatter.png" style="max-width: 40px;" alt="">
                    </div>
                    <div class="my-1">
                        PAYTABLE WINS ARE SHOWN FOR BET MULTIPLIER X1.
                    </div>
                    <div class="my-1">
                        PAYTABLE WINS ARE SHOWN IN CREDITS
                    </div>
                </div>
    
                <div class="divider-container mt-5">
                    <div class="divider-wrapper">
                        <div class="divider-text" style="font-weight: bold;">243 WAYS</div>
                    </div>
                </div>
    
                <div class="d-flex justify-content-center align-items-center">
                    <div style="width: 90%;background-color: white;height: 2px;"></div>
                </div>
    
                <div class="row px-3 my-3">
                    <div class="col-lg-3 col-md-12 col-sm-12 text-center px-4">
                        <img src="tick.png" class="mx-5" style="max-width: 50%;" alt="">
                    </div>
                    <div class="col-lg-9 col-md-12 col-lg-12">
                        REELS = 5
                        <div class="d-flex justify-content-start align-items-center">
                            PLAY 5 REELS WITH MINIMUM BET 30 MULTIPLIED BY DENOMINATION.
                        </div>
                    </div>
                </div>
                <div>
                    <div style="width: 90%;margin-bottom: 140px;" class="mx-auto mt-3 pb-3">
                        <div>
                            ALL WINNING COMBINATIONS PAY FROM LEFT TO RIGHT ON ADJACENT REELS BEGINNING FROM LEFTMOST EXCEPT <img src="scatter.png" style="width: 40px;" alt="">
                        </div>
                        <div>
                            ALL WINS ARE MULTIPLIED BY THE BET MULTIPLIER. ONLY THE HIGHEST WINNING COMBINATION IS PAID ON EACH PAY WAY.
                        </div>
                    </div>
                </div>
            </div>
    
            <div class="text-center py-3 w-100" style="position: fixed;bottom: 0;background-color: #191818;color: white;font-size: 1.0rem;z-index: 9999;margin: 0 !important;">
                <div>
                    MALFUNCTION VOIDS ALL PLAYS AND PAYS.
                </div>
                <div class="my-2 d-flex justify-content-center align-items-center">
                    <div class="d-flex justify-content-center align-items-center" style="height: 45px;width: 45px;border-radius: 50%;border-color: white;border-style: solid;">
                        <i id="close_info_button" class="fa fa-arrow-left fa-2x py-2 px-2"></i>
                    </div>
                </div>
            </div>
        </div>


        <div id="device_overlay">
            <div class="d-flex flex-column justify-content-center align-items-center text-center p-4" 
                style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.99); color: white; font-size: 1.5rem; text-align: center; z-index: 9999; display: flex;">
                <div class="container">
                    <h2 class="fw-bold">FOR AN OPTIMAL GAMING EXPERIENCE</h2>
                    <p class="lead">USE A MOBILE DEVICE</p>
                    <div class="my-3 text-center my-3">
                        <i class="fa fa-mobile-alt fa-3x"></i>
                    </div>
                </div>
            </div>
        </div>

        <div id="winOverlay" class="mobile-wrapper" >
            <button id="closeBtn" class="btn-close btn-close-white" aria-label="Close"></button>
            <div id="coinsContainer"></div>
            <div class="sunburst-container">
                <div id="sunburst"  class="sunburst mega-win-color"></div>
            </div>
            <div class="win-content">
                <!-- <h2 id="winText" class="win-text big-win"> -->
                <img id="winImg" style="max-width: 200px;" src="winlevels/bigwin.png" alt="">
                </h2>
                <div class="counter-text" id="winAmount">$0</div>
            </div>
        </div>
        
        <div id="jdb_overlay" >
            <div style="height: 100%; width: 100%;" class="d-flex justify-content-center align-items-center">
                <div class="row">
                    <div class="d-flex justify-content-center align-items-center mx-auto">
                        <div>
                            <img src="jdb_logo.png" style="max-width: 100%;" alt="mx-auto">
                            <div class="d-flex justify-content-center mx-auto">
                                <div class="loader-container" style="width: 50%; border-style: solid; border-width: 1px; border-radius: 12px;">
                                    <div class="loader-bar" style="border-radius: 12px;" id="loader-bar"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>  
    
        <div id="kong_overlay">
            <div class="d-flex justify-content-center">
                <button class="glowing-button text-white" onclick="hideKongOverlay()">START</button>
            </div>
        </div>

        <div id="credits_overlay" style="height: 100%;position: absolute;z-index: 999999;background-color: rgb(0,0,0,0.8);width:100%;display: none;">
            <!-- <div style="margin-top: 70%;">
                <div class="d-flex justify-content-center align-items-center my-2">
                    <img style="max-width: 90%;" src="youve_won.png" alt="">
                </div>
                <div id="display_accumulated_freespin_amount" class="russo-one-regular text-container gradient-text2 d-flex justify-content-center align-items-center" style="font-size: 2.5rem;">
                </div>
                <div class="d-flex justify-content-center align-items-center my-2">
                    <img style="max-width: 70%;" src="credits.png" alt="">
                </div>
                
            </div> -->
            <div id="win-container" class="fade-from-top hidden-fade" style="margin-top: 70%;">
                <div class="d-flex justify-content-center align-items-center my-2">
                    <img style="max-width: 90%;" src="youve_won.png" alt="">
                </div>
                <div id="display_accumulated_freespin_amount" class="russo-one-regular text-container gradient-text2 d-flex justify-content-center align-items-center" style="font-size: 2.5rem;">
                    <!-- 49.00 -->
                </div>
                <div class="d-flex justify-content-center align-items-center my-2">
                    <img style="max-width: 70%;" src="credits.png" alt="">
                </div>
            </div>

            <div class="ember-container" id="emberContainer"></div>
            <div class="falling-coins-container" id="fallingCoinsContainer"></div>
            <div class="coins-container"></div>
        </div>
    
        <div id="game-container" class="victor-mono">
            <!-- <div id="credits_overlay" style="position: absolute; z-index: 9999; height: 100%; max-height: 5100px;">
                <img src="credits.gif" style="position: absolute; bottom: 0;width: inherit;" alt="">
            </div> -->
            <div>
                <img id="img_top" src="bg-top6.gif" style="width: 100%;height: auto;" alt="">
                <img id="img_top_volcano_part_1" src="volcano.gif" style="width: 100%;height: auto;display: none;" alt="">
                <img id="img_top_volcano_part_3x" class="part2-volcano" src="multipliers/part2/3x.gif" style="width: 100%;height: auto;display: none;" alt="">
                <img id="img_top_volcano_part_6x" class="part2-volcano" src="multipliers/part2/6x.gif" style="width: 100%;height: auto;display: none;" alt="">
                <img id="img_top_volcano_part_9x" class="part2-volcano" src="multipliers/part2/9x.gif" style="width: 100%;height: auto;display: none;" alt="">
                <img id="img_top_volcano_part_18x" class="part2-volcano" src="multipliers/part2/18x.gif" style="width: 100%;height: auto;display: none;" alt="">
                <img id="img_top_volcano_part_36x" class="part2-volcano" src="multipliers/part2/36x.gif" style="width: 100%;height: auto;display: none;" alt="">
                <img id="img_top_volcano_part_72x" class="part2-volcano" src="multipliers/part2/72x.gif" style="width: 100%;height: auto;display: none;" alt="">
                <img id="img_top_volcano_eruption" class="part3-volcano" src="volcano_eruption.gif" style="width: 100%;height: auto;display: none;" alt="">
            </div>
            <div id="playground" style="position: relative; overflow: hidden;min-height: 35vh; width: 100%; background-size: cover; z-index: 99;">
                <!-- Start Free Spins Overlay -->
                <div id="startfreespinsoverlay" style="display: none; position: absolute; top: 0; left: 0; height: 100%; width: 100%; z-index: 999999;">
                    <div class="d-flex justify-content-center align-items-center" style="height: 100%; width: 100%;">
                        <div id="startfreespinsbutton" onclick="startFreeSpins()" class="py-1 px-3 text-white" style="border-radius: 6px; border: 2px white solid; font-size: 0.75rem; background-color: rgba(0, 0, 0, 0.8);">
                            PRESS REEL TO START THE BONUS
                        </div>
                    </div>
                </div>


                <div id="display_win_amount" style="display: none;position: absolute; top: 0; left: 0; height: 100%; width: 100%; z-index: 999; background-color: rgba(0,0,0,0.7);">
                    <div id="win-amount2" class="russo-one-regular text-container  gradient-text" style="position: absolute; left: 50%; transform: translateX(-50%); text-align: center;border-radius: 10px; font-size: 2.4rem; ">
                    </div>
                </div>

                <!-- Free Spins Overlay -->
                <div id="freespinsoverlay" style="display: none; position: absolute; top: 0; left: 0; background-color: rgba(0, 0, 0, 0.8); height: 100%; width: 100%; z-index: 999999;">
                    <div class="py-3 px-3 d-flex justify-content-center align-items-center" style="height: 100%;width:100%;">
                        <img class="py-2 px-2" id="freespinsoverlayimg" src="freespinsoverlay.png" style="width: 85%; height: auto;" alt="">
                        <img class="py-2 px-2" id="freespinsoverlayimg2" src="additionalfreespins.png" style="display: none; width: 85%; height: auto;" alt="">
                    </div>
                </div>

                <!-- Game Canvas Content -->
                <div class="game-canvas-container">
                    <!-- Free Spins Indicator -->
                    <div id="free-spins-indicator" class="free-spins-indicator">
                        FREE SPINS: <span id="free-spins-count">0</span> | MULTIPLIER: <span id="bonus-multiplier">0</span>x
                    </div>

                    <!-- Win Message -->
                    <div id="win-message" class="win-message">
                        <div>BIG WIN!</div>
                        <div id="win-amount">0.00</div>
                    </div>
                    
                    <!-- Canvas for the slot machine -->
                    <canvas id="slotMachine"></canvas>
                    <!-- Removed duplicate win-amount2 display -->
                </div>
            </div>

            <!-- Controls -->
            <div class="game-controls p-2">
                <div id="results_holder" class="w-100 text-center text-white d-flex justify-content-center align-items-center" style="margin-top: -22px;height: 25px; font-size: 1.2rem;">
                    <div style="margin: 5px 0px;">
                        WIN <span class="px-1" id="update_winnings">0.00</span>
                    </div>
                </div>
                <div id="freespins_display" style="display: none; justify-content: center; align-items: center; padding-top: 2px;max-width: 100%;height: 80px;">
                    <img class="fs-text-image"  src="freespin_part_a.png" alt="">
                    <span class="px-3" id="remaining_fs_holder" >0</span>
                    <img class="fs-text-image" src="freespin_part_b.png"  alt="">
                    <span class="px-3" id="total_fs_holder">0</span>
                </div>
                <div id="normalspins_display" style="display: flex; justify-content: center; align-items: center; padding-top: 2px">
                    <div id="autoPlayButton" class="rounded-circle d-flex justify-content-center align-items-center autoplay-button" style="background-image: url('autospinbcg.png');background-size: cover;">
                        <img src="autospininnerimg.png" class="autospininner-img"  alt="">
                    </div>
                    <div id="spinButton" class="mx-4 d-flex justify-content-center align-items-center spin-button" style="border-radius: 50%;background-image: url('spinbcg.png');background-size: cover;">
                        <div id="remainingAutoSpins" style="z-index: 2;position: absolute;color: darkorange;font-weight:bolder;font-size: 1.5rem;">
                        </div>
                        <div class="d-flex justify-content-center align-items-center spin-img" id="spin_img" style="background: url('spininnerimg.png');background-size: cover;">
                            
                        </div>
                    </div>
                    
                    <!-- Stake button that opens the overlay -->
                    <div id="stakeButton" class="text-center d-flex justify-content-center align-items-center stake-button" style="background-image: url('totalbetbcg.png');background-size: cover;color: orange;font-size: 0.85rem;line-height: 1;font-weight: 900;border-radius: 50%;">
                        <div>
                            <div class="d-flex justify-content-center">
                                <img src="totalbetinnerimg.png" class="totalbetinner-img"  alt="">
                            </div>
                            <div class="text-center">
                                <span id="currentStake" class="current-stake">0.3</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="container mb-2">
                    <div style="display: flex; width: 100%; position: relative; align-items: center;">
                        <div onclick="displaySettingsOverlay2()" id="settingsButton" style="border-radius: 50%;width: 50px; height: 50px;background-image: url('settings.png');background-size: cover;">
                        </div>

                        <script>
                            function displaySettingsOverlay2() {
                                settingsOverlay.style.display = 'block';
                            };
                        </script>

                        <!-- Button at the center -->
                        <div style="position: absolute; left: 50%; transform: translateX(-50%); text-align: center;">
                            <span class="text-center">
                                <span class="badge px-4 py-2 text-white" style="background-color: rgba(0,0,0,0.7);">CREDIT: <span id="balanceText">...</span></span>
                                <br>
                                <span class="text-white text-center" style="font-size: 1.0rem;">
                                    &lt; <span>DEMO GAME</span> &gt;
                                </span>
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    
        <!-- Stake Selection Overlay -->
        <div id="stakeOverlay" class="overlay" style="margin: 0 !important;padding: 0 !important;">
            <div class="divider-container">
                <div class="divider-wrapper">
                    <div class="divider"></div>
                    <div class="divider-text">TOTAL BET</div>
                    <div class="divider"></div>
                </div>
            </div>
            <div class="overlay-content-stake ">
                <div class="overlay-header">FUN</div>
                <div class="options-grid mx-auto" id="stakeOptions">
                    <button class="option-button" data-value="3.0">3.0</button>
                    <button class="option-button" data-value="1.5">1.5</button>
                    <button class="option-button" data-value="0.9">0.9</button>
                    <button class="option-button" data-value="0.6">0.6</button>
                    <button class="option-button selected" data-value="0.3">0.3</button>
                </div>
                <div class="text-center text-white mt-5 pt-5" style="margin-bottom: 100px;">
                    <span >
                        Reels: 5
                    </span>
                </div>
                <div class="overlay-footer w-100">
                    <button style="display: none;" class="cancel-button px-4" id="cancelStake">Cancel</button>
                    <button class="confirm-button px-5" id="confirmStake">OK</button>
                </div>
            </div>
        </div>
    
        <!-- Auto Spin Overlay -->
        <div id="autoSpinOverlay" class="overlay">
            <div class="divider-container">
                <div class="divider-wrapper">
                    <div class="divider"></div>
                    <div class="divider-text">AUTOPLAYS</div>
                    <div class="divider"></div>
                </div>
            </div>
            <div class="overlay-content w-100" style="margin-top: 20px !important;">
                <div class="mb-2 text-white">
                    NUMBER OF SPINS
                </div>
                <div class="options-grid" id="autoSpinOptions">
                    <button class="option-button" data-value="0"><i class="fa fa-stop"></i></button>
                    <button class="option-button" data-value="999">999</button>
                    <button class="option-button" data-value="200">200</button>
                    <button class="option-button" data-value="100">100</button>
                    <button class="option-button" data-value="30">30</button>
                </div>
                
<div class="mt-4 mb-2 text-white">
    LOSS LIMIT
</div>
<div class="options-grid" id="lossLimitOptions">
    <button class="option-button" data-value="Infinity"><i class="fa fa-infinity"></i></button>
    <button class="option-button" data-value="500">500<span style="font-size: 0.7rem;">x BET</span></button>
    <button class="option-button" data-value="100">100<span style="font-size: 0.7rem;">x BET</span></button>
    <button class="option-button" data-value="50">50<span style="font-size: 0.7rem;">x BET</span></button>
    <button class="option-button" data-value="10">10<span style="font-size: 0.7rem;">x BET</span></button>
</div>
                <div class="divider-container my-3">
                    <div class="divider-wrapper">
                        <div style="height: 2px;background-color: #e4d594;width: 25vw;"></div>
                        <div class="divider-text" >QUICK SPIN</div>
                        <div style="height: 2px;background-color: #e4d594;width: 25vw;"></div>
                    </div>
                </div>
                <div class="d-flex justify-content-center align-items-center">
                    <img id="quickspin-toggle" src="quickspin-a.png" style="height: 60px;width: 60px;" alt="">
                    <img id="quickspin-toggle2" src="quickspin-b.png" style="height: 60px;width: 60px;display: none;" alt="">
                </div>
                <div class="overlay-footer" style="margin-top: 70px;">
                    <button class="cancel-button" id="cancelAutoSpin">Cancel</button>
                    <button class="confirm-button px-4" id="confirmAutoSpin">Ok</button>
                </div>
            </div>
        </div>
    
        <!-- Settings Overlay -->
        <div id="settingsOverlay" class="overlay" style="background-color: rgb(0,0,0,0.8); margin: 0 !important; padding: 0 !important;">
            <div onclick="hideSettingsOverlay()" class="overlay-content w-100" style="height: 100%; margin: 0 !important; padding: 0 !important;">
                <div>
                    <div style="display: none;">
                        <div class="d-flex justify-content-center">
                            <div id="soundEffectsOption" class="sound-option selected mx-auto">
                                <div>
                                    <span id="soundEffectsIcon" class="icon-container"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="overlay-footer" style="position: absolute;background-image: url('bcg-settings.png');background-size: cover;margin: 0 !important;padding: 0 !important;">
                <div class="w-100 mb-2">
                    <div class="d-flex justify-content-around align-items-center py-5 px-3 w-100">
                        <div id="info_button" class="sound-option selected">
                            <div class="d-flex justify-content-center align-items-center" style="color: #e4d594; width: 30px; height: 30px; border-radius: 50%; border-color: #e4d594; border-style: solid;">
                                <i class="fas fa-question" style="font-size: 1.2rem; font-weight: bold;"></i>
                            </div>
                        </div>
                        <div id="backgroundMusicOption" class="sound-option selected">
                            <div>
                                <span id="backgroundMusicIcon" class="icon-container">
                                    <i class="fa fa-volume-up" style="color: #e4d594; font-size: 1.4rem;"></i>
                                </span>
                            </div>
                        </div>
                    </div>
                    <div class="d-flex justify-content-center text-white">
                        <i class="fa fa-user px-1"></i> <span style="font-size: 0.7rem;">demo004817</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<script>
class CoinAnimation {
    constructor() {
        this.container = document.getElementById('fallingCoinsContainer');
        this.coins = [];
        this.screenWidth = window.innerWidth;
        this.screenHeight = window.innerHeight;
        this.isActive = true;
        this.startTime = Date.now();
        this.duration = 5000; // 5 seconds
        
        this.startAnimation();
        this.stopAfterDuration();
    }

    createCoin() {
        if (!this.isActive) return;

        const coin = document.createElement('div');
        coin.className = 'falling-coin';
        
        // Random size variation
        const sizes = ['small', '', 'large'];
        const randomSize = sizes[Math.floor(Math.random() * sizes.length)];
        if (randomSize) coin.classList.add(randomSize);

        // Random coin face (front or side for spinning effect)
        const faces = ['front', 'side'];
        const randomFace = faces[Math.floor(Math.random() * faces.length)];
        coin.classList.add(randomFace);

        // All coins start from the center
        const centerX = this.screenWidth / 2;
        coin.style.left = centerX + 'px';
        coin.style.top = '-50px';

        // Random horizontal drift - coins can fall anywhere across the screen
        const maxDrift = this.screenWidth * 0.8; // Can drift up to 80% of screen width
        const drift = (Math.random() - 0.5) * maxDrift;
        coin.style.setProperty('--drift', drift + 'px');
        
        // Random rotation
        const rotation = Math.random() * 720; // 0-720 degrees
        coin.style.setProperty('--rotation', rotation + 'deg');

        // Random animation duration
        const duration = 2 + Math.random() * 2; // 2-4 seconds
        coin.style.animationDuration = duration + 's';

        // Random delay
        const delay = Math.random() * 0.5; // 0-0.5 seconds delay
        coin.style.animationDelay = delay + 's';

        this.container.appendChild(coin);
        
        const coinObj = {
            element: coin,
            startTime: Date.now() + (delay * 1000),
            duration: duration * 1000,
            removed: false
        };
        
        this.coins.push(coinObj);

        // Remove coin after animation completes
        setTimeout(() => {
            this.removeCoin(coinObj);
        }, (duration + delay) * 1000 + 500);
    }

    removeCoin(coinObj) {
        if (coinObj.removed) return;
        coinObj.removed = true;
        
        if (coinObj.element && coinObj.element.parentNode) {
            coinObj.element.parentNode.removeChild(coinObj.element);
        }
        
        const index = this.coins.indexOf(coinObj);
        if (index > -1) {
            this.coins.splice(index, 1);
        }
    }

    startAnimation() {
        // Create coins at random intervals
        this.coinInterval = setInterval(() => {
            if (this.isActive) {
                this.createCoin();
            }
        }, 50 + Math.random() * 10); // Create new coin every 100-300ms
    }

    stopAfterDuration() {
        setTimeout(() => {
            this.isActive = false;
            clearInterval(this.coinInterval);
            
            // Clean up remaining coins after a delay
            setTimeout(() => {
                this.coins.forEach(coinObj => {
                    this.removeCoin(coinObj);
                });
            }, 5000);
        }, this.duration);
    }

    updateScreenSize() {
        this.screenWidth = window.innerWidth;
        this.screenHeight = window.innerHeight;
    }
}

class EmberAnimation {
    constructor() {
        this.container = document.getElementById('emberContainer');
        this.embers = [];
        this.maxEmbers = 400;
        this.screenWidth = window.innerWidth;
        this.screenHeight = window.innerHeight;
        this.init();
    }

    init() {
        this.createEmbers();
        this.startAnimation();
    }

    createEmber() {
        const ember = document.createElement('div');
        ember.className = 'ember';
        
        // Random size variation
        const sizes = ['small', 'medium', 'large'];
        const randomSize = sizes[Math.floor(Math.random() * sizes.length)];
        ember.classList.add(randomSize);

        // Random starting position along the bottom
        const startX = Math.random() * this.screenWidth;
        ember.style.left = startX + 'px';
        ember.style.bottom = '0px';

        // Random angle between 60-120 degrees (converted to radians)
        const angleInDegrees = 75 + Math.random() * 60; // 60-120 degrees
        const angleInRadians = (angleInDegrees * Math.PI) / 180;
        
        // Ensure ember reaches 40-50% of screen height
        const minHeight = this.screenHeight * 0.4; // 40% of screen height
        const maxHeight = this.screenHeight * 0.5; // 50% of screen height
        const targetHeight = minHeight + Math.random() * (maxHeight - minHeight);
        
        // Calculate total distance based on angle and target height
        const totalDistance = targetHeight / Math.sin(angleInRadians);
        
        // Calculate x and y components
        const totalX = Math.cos(angleInRadians) * totalDistance;
        const totalY = Math.sin(angleInRadians) * totalDistance;
        
        // Set movement values for different animation stages
        ember.style.setProperty('--x-10', (totalX * 0.1) + 'px');
        ember.style.setProperty('--y-10', (-totalY * 0.1) + 'px');
        ember.style.setProperty('--x-50', (totalX * 0.5) + 'px');
        ember.style.setProperty('--y-50', (-totalY * 0.5) + 'px');
        ember.style.setProperty('--x-80', (totalX * 0.8) + 'px');
        ember.style.setProperty('--y-80', (-totalY * 0.8) + 'px');
        ember.style.setProperty('--x-100', totalX + 'px');
        ember.style.setProperty('--y-100', (-totalY) + 'px');
        
        // Random rotation
        const rotation = Math.random() * 360;
        ember.style.setProperty('--rotation', rotation + 'deg');

        // Random animation duration
        const duration = 4 + Math.random() * 3; // 4-7 seconds
        ember.style.animationDuration = duration + 's';

        // Random delay
        const delay = Math.random() * 1; // 0-1 seconds delay
        ember.style.animationDelay = delay + 's';

        this.container.appendChild(ember);
        
        // Track this ember for edge detection
        const emberObj = {
            element: ember,
            startTime: Date.now() + (delay * 1000),
            duration: duration * 1000,
            startX: startX,
            startY: this.screenHeight, // Start from bottom
            totalX: totalX,
            totalY: totalY,
            angle: angleInDegrees,
            removed: false
        };
        
        this.embers.push(emberObj);

        // Remove ember after animation completes
        setTimeout(() => {
            this.removeEmber(emberObj);
        }, (duration + delay) * 1000 + 500); // Add small buffer

        return emberObj;
    }

    removeEmber(emberObj) {
        if (emberObj.removed) return;
        emberObj.removed = true;
        
        if (emberObj.element && emberObj.element.parentNode) {
            emberObj.element.parentNode.removeChild(emberObj.element);
        }
        
        const index = this.embers.indexOf(emberObj);
        if (index > -1) {
            this.embers.splice(index, 1);
        }
    }

    checkEdges() {
        const now = Date.now();
        const screenWidth = this.screenWidth;
        const screenHeight = this.screenHeight;
        
        this.embers.forEach(emberObj => {
            if (emberObj.removed || now < emberObj.startTime) return;
            
            const elapsed = now - emberObj.startTime;
            const progress = Math.min(elapsed / emberObj.duration, 1);
            
            // Calculate current position based on animation progress
            let progressX, progressY;
            
            if (progress <= 0.1) {
                const stageProgress = progress / 0.1;
                progressX = emberObj.totalX * 0.1 * stageProgress;
                progressY = emberObj.totalY * 0.1 * stageProgress;
            } else if (progress <= 0.5) {
                const stageProgress = (progress - 0.1) / 0.4;
                progressX = (emberObj.totalX * 0.1) + (emberObj.totalX * 0.4 * stageProgress);
                progressY = (emberObj.totalY * 0.1) + (emberObj.totalY * 0.4 * stageProgress);
            } else if (progress <= 0.8) {
                const stageProgress = (progress - 0.5) / 0.3;
                progressX = (emberObj.totalX * 0.5) + (emberObj.totalX * 0.3 * stageProgress);
                progressY = (emberObj.totalY * 0.5) + (emberObj.totalY * 0.3 * stageProgress);
            } else {
                const stageProgress = (progress - 0.8) / 0.2;
                progressX = (emberObj.totalX * 0.8) + (emberObj.totalX * 0.2 * stageProgress);
                progressY = (emberObj.totalY * 0.8) + (emberObj.totalY * 0.2 * stageProgress);
            }
            
            const currentX = emberObj.startX + progressX;
            const currentY = emberObj.startY - progressY; // Subtract because we're moving up
            
            // Check if ember has reached any edge of the screen (with some margin)
            if (currentX < -20 || currentX > screenWidth + 20 || 
                currentY < -20 || currentY > screenHeight + 20) {
                this.removeEmber(emberObj);
            }
        });
    }

    createEmbers() {
        // Create initial batch of embers
        for (let i = 0; i < 10; i++) {
            setTimeout(() => {
                this.createEmber();
            }, Math.random() * 10);
        }
    }

    startAnimation() {
        // Continuously create new embers
        setInterval(() => {
            if (this.embers.length < this.maxEmbers) {
                this.createEmber();
            }
        }, 40 + Math.random() * 30); // Create new ember every 200-500ms
        
        // Check for embers reaching edges
        setInterval(() => {
            this.checkEdges();
        }, 100); // Check every 100ms
    }

    updateScreenSize() {
        this.screenWidth = window.innerWidth;
        this.screenHeight = window.innerHeight;
    }
}

// Start the animations when page loads
window.addEventListener('load', () => {
    new EmberAnimation();
    new CoinAnimation(); // Start coin animation immediately
});

// Handle window resize
window.addEventListener('resize', () => {
    // Update screen size and restart
    const emberContainer = document.getElementById('emberContainer');
    const coinContainer = document.getElementById('fallingCoinsContainer');
    emberContainer.innerHTML = '';
    coinContainer.innerHTML = '';
    setTimeout(() => {
        new EmberAnimation();
        new CoinAnimation();
    }, 100);
});
</script>


<script>
    // Game configuration
    const REEL_COUNT = 5;
    // Different number of symbols per reel for progressive stopping
    const SYMBOLS_PER_REEL_ARRAY = [60, 63, 66, 69, 72];
    const SYMBOLS_PER_REEL = 3; // Keep this for consistency with UI calculations
    const SYMBOL_SIZE = 100;
    const REEL_WIDTH = SYMBOL_SIZE;
    const REEL_HEIGHT = SYMBOL_SIZE * SYMBOLS_PER_REEL;
    // Individual wall thickness for each wall (top, right, bottom, left)
    const WALL_THICKNESS = {
        top: 20,
        right: 7,
        bottom: 80,
        left: 7
    };
    const GAME_WIDTH = REEL_WIDTH * REEL_COUNT + WALL_THICKNESS.left + WALL_THICKNESS.right;
    const GAME_HEIGHT = REEL_HEIGHT + WALL_THICKNESS.top + WALL_THICKNESS.bottom;
    
    // Extra symbols to draw above and below visible area for smooth scrolling
    const EXTRA_SYMBOLS = 2;

    const SYMBOLS = [
        { name: 'Treasure Chest', image: 'treasurechest.png', color: '#ff5252', payouts: [0, 0, 40, 100, 250], normal_scale: 1.2, z_index: 97 },
        { name: 'Explorer', image: 'explorer.png', color: '#ffeb3b', payouts: [0, 0, 30, 80, 200], normal_scale: 1.2, z_index: 95 },
        { name: 'Compass', image: 'compass.png', color: '#ff9800', payouts: [0, 0, 25, 60, 175], normal_scale: 1.15, z_index: 94 },
        { name: 'Binoculars', image: 'binoculars.png', color: '#9c27b0', payouts: [0, 0, 20, 50, 150], normal_scale: 1.15, z_index: 94 },
        { name: 'A', image: 'a.png', color: '#f44336', payouts: [0, 0, 10, 20, 100], normal_scale: 1.10, z_index: 93 },
        { name: 'K', image: 'k.png', color: '#4caf50', payouts: [0, 0, 8, 15, 90], normal_scale: 1.10, z_index: 93 },
        { name: 'Q', image: 'q.png', color: '#ffc107', payouts: [0, 0, 6, 12, 80], normal_scale: 1.10, z_index: 93 },
        { name: 'J', image: 'j.png', color: '#2196f3', payouts: [0, 0, 5, 10, 70], normal_scale: 1.10, z_index: 93 },
        { name: 'Wild', image: 'wild.png', color: '#00bcd4', payouts: [0, 0, 50, 125, 300], normal_scale: 1.25, z_index: 120 },
        { name: 'Scatter', image: 'scatter.png', color: '#e91e63', payouts: [0, 0, 5, 20, 50], normal_scale: 1.30, z_index: 97 }
    ];

    
    const SYMBOL_SCALE_MAP = {
        'Treasure Chest': 1.4,
        'Explorer': 1.3,
        'Compass': 1.3,
        'Binoculars': 1.3,
        'A': 1.2,
        'K': 1.2,
        'Q': 1.2,
        'J': 1.2,
        'Wild': 1.55,
        'Scatter': 1.8
    };


    // Wall colors (different backgrounds)
    const WALL_BACKGROUNDS = [
        '#3a0ca3', // top
        '#4361ee', // right
        '#4cc9f0', // bottom
        '#7209b7'  // left
    ];

    // Global variables for animations
    let activeAnimations = {};
    let wildFrameImages = [];
    let loadedWildFrames = 0;
    const wildFrameCount = 33;

    // Get canvas and context
    const canvas = document.getElementById('slotMachine');
    const ctx = canvas.getContext('2d');
    
    // Get DOM elements
    const spinButton = document.getElementById('spinButton');
    const autoPlayButton = document.getElementById('autoPlayButton');
    const stakeButton = document.getElementById('stakeButton');
    const settingsButton = document.getElementById('settingsButton');
    const featuresButton = document.getElementById('featuresButton');
    const featuresOverlay = document.getElementById('featuresOverlay');
    const remainingAutoSpins = document.getElementById('remainingAutoSpins');
    const spinButtonInnerImage = document.getElementById('spin_img');
    const balanceText = document.getElementById('balanceText');
    const currentStakeElement = document.getElementById('currentStake');
    const stakeOverlay = document.getElementById('stakeOverlay');
    const infoOverlay = document.getElementById('gameinfo_overlay');
    const closeInfoButton = document.getElementById('close_info_button');
    const infoButton = document.getElementById('info_button');
    const autoSpinOverlay = document.getElementById('autoSpinOverlay');
    const stakeOptions = document.getElementById('stakeOptions');
    const autoSpinOptions = document.getElementById('autoSpinOptions');
    const cancelStakeButton = document.getElementById('cancelStake');
    const confirmStakeButton = document.getElementById('confirmStake');
    const cancelAutoSpinButton = document.getElementById('cancelAutoSpin');
    const confirmAutoSpinButton = document.getElementById('confirmAutoSpin');
    const winMessageElement = document.getElementById('win-message');
    const winAmountElement = document.getElementById('win-amount');
    const freeSpinsIndicator = document.getElementById('free-spins-indicator');
    const freeSpinsCountElement = document.getElementById('free-spins-count');
    const bonusMultiplierElement = document.getElementById('bonus-multiplier');
    const settingsOverlay = document.getElementById('settingsOverlay');
    const soundEffectsOption = document.getElementById('soundEffectsOption');
    const backgroundMusicOption = document.getElementById('backgroundMusicOption');
    const soundEffectsIcon = document.getElementById('soundEffectsIcon');
    const backgroundMusicIcon = document.getElementById('backgroundMusicIcon');
    const startFreeSpinsOverlay = document.getElementById('startfreespinsoverlay');
    const startFreeSpinsButton = document.getElementById('startFreeSpinsbutton');
    const freeSpinsOverlay = document.getElementById('freespinsoverlay');
    const freeSpinsOverlayImg = document.getElementById('freespinsoverlayimg');
    const freeSpinsOverlayImg2 = document.getElementById('freespinsoverlayimg2');
    const quickspinToggleImg = document.getElementById('quickspin-toggle');
    const loaderBar = document.getElementById('loader-bar');
    const jdbOverlay = document.getElementById('jdb_overlay');
    const kongOverlay = document.getElementById('kong_overlay');
    const deviceOverlay = document.getElementById('device_overlay');
    const lossLimitOptions = document.getElementById('lossLimitOptions');

    // Game state
    let spinning = false;
    let reels = [];
    let finalResults = [];
    let winAmount = 0;
    let winAmountDisplay = 0;
    let winAnimationStartTime = 0;
    let isAnimatingWin = false;
    let symbolImages = {}; // Object to store loaded images
    let imagesLoaded = 0;
    let totalImages = SYMBOLS.length;
    let balance = 0; // Starting balance
    let stake = 0.3; // Default bet amount
    let autoSpins = 0;
    let currentInterval;
    let selectedStake = 0.3; // Default stake value
    let selectedAutoSpins = 0; // Default auto spins value
    let initialBalance = 0;
    let lossLimit = Infinity; // Default to no limit
    let selectedLossLimit = Infinity; // Default selected loss limit
    let autoSpinsStopped = true;
    let isQuickSpinMode = false;
    
    // Free spins state
    let freeSpinTriggeredRecently = false;
    let isFreeSpinMode = false;
    let freeSpinCount = 0;
    let remainingFreeSpinCount = 0;
    let bonusMultiplier = 0;
    let originalBetAmount = 0;
    
    // Sound control variables
    let soundEffectsEnabled = true;
    let backgroundMusicEnabled = true;
    let tempSoundEffectsEnabled = true;
    let tempBackgroundMusicEnabled = true;

    let accumulatedAmountDuringFreespin = 0;
    let freeSpinEndedRecently = false
    
    let stoppedReelsPreFreeSpin = {
        reels: null,
        winningPositions: null,
        win: 0,
        bonusMultiplier: 0,
        timestamp: null
    };
    // Game mode
    const gameMode = {
        'mode': 'live'
    };
    const currentDemoFeature = {
        "feature": "normal spin"
    };

    
    
    // Audio System - Creates a centralized audio manager
    class AudioManager {
        constructor() {
            // Sound effects collection
            this.sounds = {};
            
            // Initialize audio objects with better handling
            this.sounds.background = this.createSound('sounds/SE_Base_BG.mp3', true, 0.5);
            this.sounds.bigWin = this.createSound('sounds/SE_BigWin.mp3', false, 0.8);
            this.sounds.reelSpeedUp = this.createSound('sounds/SE_ReelSpeedUp.mp3', false, 0.9);
            this.sounds.freeSpin = this.createSound('sounds/SE_Free_BG.mp3', true, 0.9);
            this.sounds.spin = this.createSound('sounds/SE_ButtonPress.mp3', false, 1.0);
            this.sounds.spinStop = this.createSound('sounds/SE_Spinstop.mp3', false, 0.9);
            this.sounds.win = this.createSound('sounds/SE_Scoring_01.mp3', false, 1.0);
            this.sounds.jackpot = this.createSound('sounds/SE_Jackpot.mp3', false, 1.0);
            this.sounds.megaWin = this.createSound('sounds/SE_MegaWin.mp3', false, 1.0);
            this.sounds.ultraWin = this.createSound('sounds/SE_UltraWin.mp3', false, 1.0);
            this.sounds.bonusAlarm = this.createSound('sounds/SE_BonusAlarm.mp3', false, 1.0);
            
            // Control flags
            this.soundEffectsEnabled = soundEffectsEnabled;
            this.backgroundMusicEnabled = backgroundMusicEnabled;
            
            // Preload all sounds
            this.preloadAll();
            
            // Flag to track if user interaction is needed
            this._needsUserInteraction = false;
            
            // Add global click handler to handle autoplay policy
            document.addEventListener('click', this.handleUserInteraction.bind(this), {once: true});
            
            // Add visibility change listener to handle tab focus
            document.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));
        }
        
        // Handle visibility change (pause music when tab not active)
        handleVisibilityChange() {
            if (document.hidden) {
                // Tab is not active/visible - pause background music
                if (this.sounds.background) {
                    this.sounds.background.pause();
                }
                if (this.sounds.freeSpin) {
                    this.sounds.freeSpin.pause();
                }
            } else {
                // Tab is active/visible again - resume background music if enabled
                if (this.backgroundMusicEnabled) {
                    if (isFreeSpinMode && this.sounds.freeSpin) {
                        this.sounds.freeSpin.play().catch(e => console.log("Audio play failed:", e));
                    } else if (this.sounds.background) {
                        this.sounds.background.play().catch(e => console.log("Audio play failed:", e));
                    }
                }
            }
        }
        
        // Helper to create a sound with proper settings
        createSound(src, loop = false, volume = 1.0) {
            const sound = new Audio();
            sound.src = src;
            sound.loop = loop;
            sound.volume = volume;
            sound.preload = 'auto';
            
            // Add event listener to track loading
            sound.addEventListener('canplaythrough', () => {
                console.log(`Sound loaded: ${src}`);
            });
            
            return sound;
        }
        
        // Preload all sounds
        preloadAll() {
            Object.values(this.sounds).forEach(sound => {
                try {
                    sound.load();
                } catch(e) {
                    console.log(`Error preloading sound: ${e}`);
                }
            });
        }
        
        // Play a sound with proper resets and error handling
        playSound(sound) {
            // Don't play if sound effects are disabled or sound is null
            if (!this.soundEffectsEnabled || !sound) return;
            
            // For background music, check if it's enabled
            if ((sound === this.sounds.background || sound === this.sounds.freeSpin) && !this.backgroundMusicEnabled) {
                return;
            }
            
            // Reset the sound to start
            try {
                sound.currentTime = 0;
                
                // Play with error handling
                const playPromise = sound.play();
                
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log(`Audio play failed: ${error}`);
                        if (error.name === 'NotAllowedError') {
                            this._needsUserInteraction = true;
                        }
                    });
                }
            } catch(e) {
                console.log(`Error playing sound: ${e}`);
            }
        }
        
        // Handle user interaction for autoplay policy
        handleUserInteraction() {
            if (this._needsUserInteraction) {
                console.log("User interacted, attempting to play audio");
                if (this.backgroundMusicEnabled && !document.hidden) {
                    this.sounds.background.play().catch(e => console.log("Still can't play background:", e));
                }
                this._needsUserInteraction = false;
            }
        }
        
        // Play background music
        playBackgroundMusic() {
            if (!this.backgroundMusicEnabled || document.hidden) return;
            if (!isFreeSpinMode){
                this.playSound(this.sounds.background);
            } else {
                this.playSound(this.sounds.freeSpin);
            }
            
        }
        
        // Play spin sound
        playSpinSound() {
            this.playSound(this.sounds.spin);
            // Also play the reel speed up sound with a slight delay
            setTimeout(() => {
                this.playSound(this.sounds.reelSpeedUp);
            }, 100);
        }
        
        // Play spin stop sound
        playSpinStopSound() {
            this.stopSound(this.sounds.reelSpeedUp);
            this.playSound(this.sounds.spinStop);
        }
        
        // Play win sound based on amount
        playWinSound(amount = 0) {
            if (!isFreeSpinMode && soundEffectsEnabled){
                if (amount >= 300) {
                    this.playSound(this.sounds.ultraWin);
                } else if (amount >= 200) {
                    this.playSound(this.sounds.megaWin);
                } else if (amount >= 100) {
                    this.playSound(this.sounds.bigWin);
                } 
            }
            // else {
            //     this.playSound(this.sounds.win);
            // }
        }
        
        // Stop a specific sound
        stopSound(sound) {
            if (sound) {
                sound.pause();
                sound.currentTime = 0;
            }
        }
        
        // Stop all sounds
        stopAllSounds() {
            Object.values(this.sounds).forEach(sound => {
                sound.pause();
                sound.currentTime = 0;
            });
        }
        
        // Toggle sound effects on/off
        toggleSoundEffects() {
            this.soundEffectsEnabled = !this.soundEffectsEnabled;
            soundEffectsEnabled = this.soundEffectsEnabled;
            return this.soundEffectsEnabled;
        }
        
        // Toggle background music on/off
        toggleBackgroundMusic() {
            //toggle also sound effects:
            this.toggleSoundEffects()

            this.backgroundMusicEnabled = !this.backgroundMusicEnabled;
            backgroundMusicEnabled = this.backgroundMusicEnabled;
            
            if (!this.backgroundMusicEnabled) {
                if (!isFreeSpinMode){
                    this.stopSound(this.sounds.background);
                }else{
                    this.stopSound(this.sounds.freeSpin)
                }
            } else {
                this.playBackgroundMusic();
            }
            
            return this.backgroundMusicEnabled;
        }
    }

    // Create the audio manager instance
    const audioManager = new AudioManager();
    
    // Start background music (will play when user interacts if autoplay is blocked)
    

    // Coin images for win animation
    coinImages = [
        "coins/0_BigWin_SS.png", "coins/1_BigWin_SS.png", "coins/2_BigWin_SS.png", "coins/3_BigWin_SS.png",
        "coins/4_BigWin_SS.png", "coins/5_BigWin_SS.png", "coins/6_BigWin_SS.png", "coins/7_BigWin_SS.png",
        "coins/8_BigWin_SS.png", "coins/9_BigWin_SS.png", "coins/10_BigWin_SS.png", "coins/11_BigWin_SS.png",
        "coins/12_BigWin_SS.png", "coins/13_BigWin_SS.png", "coins/14_BigWin_SS.png", "coins/15_BigWin_SS.png",
        "coins/16_BigWin_SS.png", "coins/17_BigWin_SS.png", "coins/18_BigWin_SS.png", "coins/19_BigWin_SS.png",
        "coins/20_BigWin_SS.png", "coins/21_BigWin_SS.png", "coins/22_BigWin_SS.png", "coins/23_BigWin_SS.png",
        "coins/24_BigWin_SS.png", "coins/25_BigWin_SS.png", "coins/26_BigWin_SS.png", "coins/27_BigWin_SS.png",
        "coins/28_BigWin_SS.png", "coins/29_BigWin_SS.png", "coins/30_BigWin_SS.png"
    ];

    // Win level configurations
      const winLevels = {
        big: {
          imgSrc: 'winlevels/bigwin.png',
          text: 'BIG WIN',
          textClass: 'big-win',
          sunburstClass: 'big-win-color',
          threshold: 100,
          coinCount: 50
        },
        mega: {
          imgSrc: 'winlevels/megawin.png',
          text: 'MEGA WIN',
          textClass: 'mega-win',
          sunburstClass: 'mega-win-color',
          threshold: 300,
          coinCount: 80
        },
        ultra: {
          imgSrc: 'winlevels/ultrawin.png',
          text: 'ULTRA WIN',
          textClass: 'ultra-win',
          sunburstClass: 'ultra-win-color',
          threshold: Infinity,
          coinCount: 40
        }
      };

function resizeCanvas() {
    const container = document.querySelector('.game-canvas-container');
    const cssWidth = container.clientWidth;
    const cssHeight = container.clientHeight;

    const dpr = 4; // 4x internal resolution

    // Logical size (CSS) - keep the visual size exactly the same
    canvas.style.width = cssWidth + 'px';
    canvas.style.height = cssHeight + 'px';

    // Internal pixel size - 2x resolution
    canvas.width = Math.floor(cssWidth * dpr);
    canvas.height = Math.floor(cssHeight * dpr);

    // Context scale to match DPR
    const ctx = canvas.getContext('2d');
    // ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
    // ctx.scale(dpr, dpr); // Apply DPR scaling
    
    // Improve image quality
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
}



function initLoading() {
        let progress = 0;

        function updateProgress() {
            progress += Math.random() * 10;

            if (progress > 100) progress = 100;

            loaderBar.style.width = progress + "%";

            // Interpolate green from 165 (orange) to 140 (darkorange)
            let green = 165 - (progress / 100) * (165 - 140);
            loaderBar.style.backgroundColor = `rgb(255, ${green}, 0)`;

            if (progress < 100) {
                setTimeout(updateProgress, 500);
            } else {
                setTimeout(() => {
                    jdbOverlay.style.display = "none";
                }, 500);
            }
        }

        updateProgress();
    }

    // Hide Kong overlay
    function hideKongOverlay() {
        kongOverlay.style.display = "none";
        audioManager.playBackgroundMusic();
        // Try to play background music (will be blocked by browsers until user interaction)
        // backgroundMusic.play().catch(e => console.log("Audio play failed:", e));
    }

    // Preload all symbol images
    function preloadImages() {
        SYMBOLS.forEach(symbol => {
            const img = new Image();
            img.crossOrigin = "anonymous"; // Avoid CORS issues
            img.setAttribute('rendering', 'crisp-edges');
            img.onload = () => {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    // All images loaded, start the game
                    initGame();
                }
            };
            img.onerror = (err) => {
                console.error(`Error loading image for ${symbol.name}:`, err);
                // Create a fallback image with just the symbol color
            };
            
            img.src = symbol.image;
            symbolImages[symbol.name] = img;
        });
    }

    function preloadWildFrames() {
        for (let i = 0; i <= wildFrameCount; i++) {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
                loadedWildFrames++;
            };
            img.src = `wildframes4/frame_${i}.png`;
            wildFrameImages.push(img);
        }
    }

    
    
    // Initialize the game
    function initGame() {
        // Resize canvas to fit container
        resizeCanvas();
        
        // In the initGame function, modify the part where initial reels are created
        for (let i = 0; i < REEL_COUNT; i++) {
            // Initialize each reel
            reels[i] = {
                position: 0,
                symbols: [],
                finalSymbols: [],
                isSpinning: false, // Track if this reel is currently spinning
                specialSymbols: {} // Track which symbols are special (larger with higher z-index)
            };
            
            // Generate initial symbols (visible + extra for scrolling)
            const totalSymbols = SYMBOLS_PER_REEL_ARRAY[i] + EXTRA_SYMBOLS * 2;
            for (let j = 0; j < totalSymbols; j++) {
                // For first reel (i === 0), exclude Wild from possible symbols
                let availableSymbols = i === 0 
                    ? SYMBOLS.filter(s => s.name !== 'Wild')
                    : SYMBOLS;
                
                const randomIndex = Math.floor(Math.random() * availableSymbols.length);
                const random_symbol_name = availableSymbols[randomIndex].name;
                reels[i].symbols.push({
                    name: random_symbol_name,
                    isSpecial: true,
                    scale: SYMBOL_SCALE_MAP[random_symbol_name] // Random scale between 1.1 and 1.6
                });
            }
            
            // Set initial final symbols (what will be shown when not spinning)
            reels[i].finalSymbols = reels[i].symbols.slice(EXTRA_SYMBOLS, EXTRA_SYMBOLS + SYMBOLS_PER_REEL);
        }
        
        // Draw initial state
        drawGame();
        
        // Update balance display
        displayBalance(balance);

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        let hasInitialized = false;

        async function initializeBalanceOnce() {
            if (hasInitialized) return;
            hasInitialized = true;

            await sleep(5000);

            if (gameMode.mode === "live") {
                initialBalance = parseFloat(playerInfo.wallet_balance).toFixed(2);
                balance = parseFloat(playerInfo.wallet_balance).toFixed(2);
                displayBalance(balance);
            } else if (gameMode.mode === "demo") {
                balance = 1000;
                initialBalance = 1000;
                displayBalance(balance);
            } else {
                balance = undefined;
            }

            console.log("Balance:", balance);
        }

        // Call it once
        initializeBalanceOnce();



        // Add event listeners
        spinButton.addEventListener('click', spin);
        autoPlayButton.addEventListener('click', toggleAutoPlay);
        settingsButton.addEventListener('click', displaySettingsOverlay);
        featuresButton.addEventListener('click', showFeaturesOverlay);
        infoButton.addEventListener('click', showInfoOverlay);
        closeInfoButton.addEventListener('click', hideInfoOverlay);
        // startFreeSpinsButton.addEventListener('click', startFreeSpins);
        quickspinToggleImg.addEventListener('click', toggleQuickSpin);
        
        // Add event listeners for overlays
        cancelStakeButton.addEventListener('click', hideStakeOverlay);
        cancelAutoSpinButton.addEventListener('click', hideAutoSpinOverlay);
        confirmAutoSpinButton.addEventListener('click', confirmAutoSpin);

        // Cancel settings
        function hideSettingsOverlay() {
            settingsOverlay.style.display = 'none';
            // Revert to previous settings (don't apply changes)
        };

        // Confirm settings
        function confirmSettings() {
            // Apply the temporary settings
            soundEffectsEnabled = tempSoundEffectsEnabled;
            backgroundMusicEnabled = tempBackgroundMusicEnabled;
            
            // Update background music based on new setting
            if (backgroundMusicEnabled) {
                backgroundMusic.play().catch(e => console.log("Audio play failed:", e));
            } else {
                backgroundMusic.pause();
            }
            
            settingsOverlay.style.display = 'none';
        };

        stakeOptions.addEventListener('click', (e) => {
            if (e.target.classList.contains('option-button')) {
                // Remove selected class from all options
                const options = stakeOptions.querySelectorAll('.option-button');
                options.forEach(option => option.classList.remove('selected'));
                
                // Add selected class to clicked option
                e.target.classList.add('selected');
                
                // Update selected stake value
                selectedStake = parseFloat(e.target.dataset.value);
            }
        });


        // Handle auto spin option selection
        autoSpinOptions.addEventListener('click', (e) => {
            if (e.target.classList.contains('option-button')) {
                // Remove selected class from all options
                const options = autoSpinOptions.querySelectorAll('.option-button');
                options.forEach(option => option.classList.remove('selected'));
                
                // Add selected class to clicked option
                e.target.classList.add('selected');
                
                // Update selected auto spins value
                selectedAutoSpins = parseInt(e.target.dataset.value);
        
                // Check if any loss limit option is currently selected
                const hasSelectedLossLimit = Array.from(
                    lossLimitOptions.querySelectorAll('.option-button')
                ).some(option => option.classList.contains('selected'));
                
                // If no loss limit is selected, automatically select the "Infinity" option
                if (!hasSelectedLossLimit) {
                    const infinityOption = lossLimitOptions.querySelector('.option-button[data-value="Infinity"]');
                    if (infinityOption) {
                        infinityOption.classList.add('selected');
                        selectedLossLimit = Infinity;
                    }
                }
            }
        });

// Handle loss limit option selection
const lossLimitOptions = document.getElementById('lossLimitOptions');
lossLimitOptions.addEventListener('click', (e) => {
    if (e.target.classList.contains('option-button')) {
        // Remove selected class from all options
        const options = lossLimitOptions.querySelectorAll('.option-button');
        options.forEach(option => option.classList.remove('selected'));
        
        // Add selected class to clicked option
        e.target.classList.add('selected');
        
        // Update selected loss limit value
        const value = e.target.dataset.value;
        selectedLossLimit = value === "Infinity" ? Infinity : parseInt(value);
    }
});



        // Add event listeners for settings
        backgroundMusicOption.addEventListener('click', toggleBackgroundMusic);
        
        // Add event listener for win overlay close button
        document.getElementById('closeBtn').addEventListener('click', closeWinAnimation);
        document.getElementById('winOverlay').addEventListener('click', closeWinAnimation);
        
        // Add window resize event listener
        window.addEventListener('resize', resizeCanvas);
        
        // Check if device is desktop
        if (window.innerWidth >= 900) {
            deviceOverlay.style.display = "none";
        }
    }


    // Bonus Frame Animation Script
function addBonusFrameToLastReel(){
    // Configuration
    const totalFrames = 8; // Number of animation frames
    const frameImages = []; // Will hold the loaded images
    let loadedImages = 0;
    let currentFrame = 0;
    let animationInterval = null;
    const lastReelIndex = 4; // 0-based index for the 5th reel
    const animationSpeed = 100; // ms between frames (adjust for faster/slower animation)
    
    // Function to initialize the bonus frame
    function initBonusFrame() {
        console.log("Initializing animated bonus frame for last reel...");
        loadFrameImages();
    }
    
    // Function to load the frame images
    function loadFrameImages() {
        for (let i = 0; i < totalFrames; i++) {
            const img = new Image();
            img.crossOrigin = "anonymous";
            // Path to your frame images - adjust as needed
            img.src = `green/${i}_Base_Reel_SpeedUp_SS.png`;
            img.onload = () => {
                loadedImages++;
                console.log(`Loaded frame ${i+1}/${totalFrames}`);
                if (loadedImages === totalFrames) {
                    console.log("All frames loaded, starting animation...");
                    hookIntoGameDrawFunctions();
                }
            };
            img.onerror = () => {
                console.error(`Failed to load frame ${i}`);
            };
            frameImages.push(img);
        }
    }
    
    // Function to hook into the game's draw functions
    function hookIntoGameDrawFunctions() {
        // Make sure the game's drawing functions exist
        if (!window.drawStoppedReels) {
            console.error("Game drawing functions not found. Make sure this script runs after the game is initialized.");
            return;
        }
        
        // Store the original drawStoppedReels function
        const originalDrawStoppedReels = window.drawStoppedReels;
        window.originalDrawStoppedReels = originalDrawStoppedReels; // Store globally for removal function
        
        // Override the drawStoppedReels function to add our bonus frame
        window.drawStoppedReels = function() {
            // Call the original function first
            originalDrawStoppedReels.apply(this, arguments);
            
            // Now add our bonus frame to the last reel
            if (loadedImages === totalFrames) {
                const canvas = document.getElementById('slotMachine');
                const ctx = canvas.getContext('2d');
                
                // Calculate dimensions
                const reelWidth = (canvas.width - WALL_THICKNESS.left - WALL_THICKNESS.right) / REEL_COUNT;
                const reelHeight = canvas.height - WALL_THICKNESS.top - WALL_THICKNESS.bottom;
                
                // Calculate position of the last reel
                const reelX = WALL_THICKNESS.left + lastReelIndex * reelWidth;
                const reelY = WALL_THICKNESS.top;
                
                // Only draw the frame if the reel is not spinning
                ctx.drawImage(frameImages[currentFrame], reelX -14 , reelY - 14, reelWidth + 27, reelHeight + 27);
            }
        };
        
        // Start the animation
        startAnimation();
    }
    
    // Function to start the animation
    function startAnimation() {
        // Clear any existing animation
        if (animationInterval) {
            clearInterval(animationInterval);
        }
        
        // Start a new animation interval
        animationInterval = setInterval(() => {
            // Update to the next frame
            currentFrame = (currentFrame + 1) % totalFrames;
            
            // Redraw the game to update the frame
            if (window.drawGame && !window.spinning) {
                window.drawGame();
            }
        }, animationSpeed);
        
        // Store interval reference globally for removal function
        window.bonusFrameAnimationInterval = animationInterval;
        
        // Also hook into the spin function to pause/resume animation
        // if (window.spin) {
        //     const originalSpin = window.spin;
        //     window.spin = function() {
        //         // Pause animation during spin
        //         clearInterval(animationInterval);
        //         animationInterval = null;
                
        //         // Call original spin function
        //         originalSpin.apply(this, arguments);
                
        //         // Resume animation after spin completes
        //         const checkSpinning = setInterval(() => {
        //             if (!window.spinning) {
        //                 clearInterval(checkSpinning);
        //                 startAnimation();
        //             }
        //         }, 500);
        //     };
        // }
    }
    
    
    // Initialize when the document is ready
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        // Wait a bit to ensure the game is fully initialized
        setTimeout(initBonusFrame, 1000);
    } else {
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(initBonusFrame, 1000);
        });
    }
};

/**
 * Checks if bonus frame is present on the last reel and removes it if found
 * Should be called at the beginning of each spin to ensure clean state
 * @returns {boolean} - Returns true if bonus frame was removed, false if no bonus frame was present
 */
function removeBonusFrameFromLastReel() {
    // Check if the original drawStoppedReels function exists in window
    if (window.originalDrawStoppedReels) {
        console.log("Removing bonus frame from last reel");
        
        // Restore the original drawStoppedReels function
        window.drawStoppedReels = window.originalDrawStoppedReels;
        
        // Clear the reference to the original function to prevent memory leaks
        window.originalDrawStoppedReels = null;
        
        // If there's an animation interval running, clear it
        if (window.bonusFrameAnimationInterval) {
            clearInterval(window.bonusFrameAnimationInterval);
            window.bonusFrameAnimationInterval = null;
            console.log("Stopped bonus frame animation");
        }
        
        // Redraw the game to update visuals
        if (window.drawGame) {
            window.drawGame();
        }
        
        return true; // Return true if successfully removed
    }
    
    // If there was no bonus frame to remove
    return false;
}
    
    
    
    
    confirmStakeButton.addEventListener('click', () => {
        stake = selectedStake;
        currentStakeElement.textContent = stake.toFixed(1);
        stakeOverlay.style.display = 'none';
    });

    // Function to create the coin fountain with 3D rotating coins
      function createCoinFountain(numberOfCoins) {
        const coinsContainer = document.getElementById('coinsContainer');
        
        // Create fountain of coins
        const containerWidth = coinsContainer.offsetWidth;
        const containerHeight = coinsContainer.offsetHeight;
        
        // Center bottom position
        const centerX = containerWidth / 2;
        
        // Adjust coin count based on screen size
        const isMobile = window.innerWidth < 576;
        const actualCoinCount = isMobile ? Math.floor(numberOfCoins * 0.6) : numberOfCoins;
        
        for (let i = 0; i < actualCoinCount; i++) {
          setTimeout(() => {
            // Create coin container element
            const coin = document.createElement('div');
            coin.className = 'coin';
            
            // Random size between 10-30px on mobile, 20-40px on desktop
            const minSize = isMobile ? 20 : 30;
            const maxSizeRange = isMobile ? 30 : 30;
            const coinSize = Math.floor(Math.random() * maxSizeRange) + minSize;
            coin.style.width = `${coinSize}px`;
            coin.style.height = `${coinSize}px`;
            
            // Create the img element inside the coin div
            const coinImg = document.createElement('img');
            coinImg.src = coinImages[0]; // Start with the first image
            coinImg.style.width = '100%';
            coinImg.style.height = '100%';
            coinImg.crossOrigin = "anonymous"; // Avoid CORS issues
            coin.appendChild(coinImg);
            
            // Start at center bottom with slight random offset
            const startX = centerX + (Math.random() - 0.5) * 50;
            coin.style.left = `${startX}px`;
            coin.style.bottom = '0px';
            
            // Add to container
            coinsContainer.appendChild(coin);
            
            // Animate the coin in a fountain pattern with 3D rotation
            animateCoinFountain(coin, coinImg, startX, containerHeight);
          }, i * 100); // Stagger the coin creation
        }
      }

      // Function to animate a single coin in a fountain pattern with 3D rotation
      function animateCoinFountain(coin, coinImg, startX, containerHeight) {
        const coinsContainer = document.getElementById('coinsContainer');
        const containerWidth = coinsContainer.offsetWidth;
        
        // Adjust physics based on screen size
        const isMobile = window.innerWidth < 576;
        const velocityMultiplier = isMobile ? 0.8 : 1;
        
        // Random angle for the fountain spread (narrower at the bottom, wider at the top)
        const angle = ((Math.random() - 0.5) * Math.PI) / 4.0; // -45 to +45 degrees
        
        // Random initial velocity (speed)
        const initialVelocity = (20 + Math.random() * 10) * velocityMultiplier;
        
        // Calculate velocity components
        const vx = initialVelocity * Math.sin(angle);
        const vy = initialVelocity * Math.cos(angle);
        
        // Animation parameters
        const gravity = 0.55 * velocityMultiplier;
        const duration = 2000 + Math.random() * 1000;
        const fps = 60;
        const totalFrames = (duration / 1000) * fps;
        
        // Animation variables
        let currentFrame = 0;
        let x = startX;
        let y = 0;
        let velocityY = vy;
        
        // 3D rotation variables
        let currentImageIndex = 0;
        const rotationSpeed = (0.1 + Math.random() * 0.2) * velocityMultiplier; // Random rotation speed
        
        // Animation function
        const animate = () => {
          if (!coin.parentNode) return; // Stop if coin was removed
          
          // Update position with gravity
          x += vx;
          velocityY -= gravity;
          y += velocityY;
          
          // Update coin position
          coin.style.left = `${x}px`;
          coin.style.bottom = `${y}px`;
          
          // Update 3D rotation - change the image based on the current frame
          currentImageIndex = (currentImageIndex + rotationSpeed) % coinImages.length;
          coinImg.src = coinImages[Math.floor(currentImageIndex)];
          
          // Add perspective tilt based on movement direction
          const tiltX = vx * 2; // Tilt based on horizontal velocity
          const tiltY = velocityY; // Tilt based on vertical velocity
          coin.style.transform = `perspective(500px) rotateX(${tiltY}deg) rotateY(${tiltX}deg)`;
          
          // Adjust shadow based on height
          const shadowBlur = Math.min(5 + y/20, 15);
          coin.style.filter = `drop-shadow(0 0 ${shadowBlur}px rgba(255, 215, 0, 0.7))`;
          
          // Check if coin is still visible
          if (y < -100 || x < -100 || x > containerWidth + 100) {
            if (coin.parentNode) {
              coin.parentNode.removeChild(coin);
            }
            return;
          }
          
          // Continue animation
          currentFrame++;
          if (currentFrame < totalFrames) {
            requestAnimationFrame(animate);
          } else {
            // Remove coin after animation completes
            if (coin.parentNode) {
              coin.parentNode.removeChild(coin);
            }
          }
        };
        
        // Start animation
        requestAnimationFrame(animate);
      }

      // Handle window resize
      window.addEventListener('resize', function() {
        // Adjust sunburst size if needed
        const sunburstContainer = document.querySelector('.sunburst-container');
        if (sunburstContainer) {
          const size = Math.min(window.innerWidth * 0.8, 400);
          sunburstContainer.style.width = `${size}px`;
          sunburstContainer.style.height = `${size}px`;
        }
      });


    // Function to update the win level visuals
      function updateWinLevel(level) {
        // const winText = document.getElementById('winText');
        const winImg = document.getElementById('winImg');
        const sunburst = document.getElementById('sunburst');
        
        // Remove all classes
        // winText.classList.remove('big-win', 'mega-win', 'ultra-win');
        sunburst.classList.remove('big-win-color', 'mega-win-color', 'ultra-win-color');
        
        // Add new classes
        // winText.classList.add(winLevels[level].textClass);
        sunburst.classList.add(winLevels[level].sunburstClass);
        
        winImg.style.transform = 'scale(0.8)';
        setTimeout(() => {
          winImg.src = winLevels[level].imgSrc;
          winImg.style.transform = 'scale(1.2)';
          setTimeout(() => {
            winImg.style.transform = 'scale(1)';
          }, 150);
        }, 150);
      }


     
    // Function to close the win animation
    function closeWinAnimation() {
        const winOverlay = document.getElementById('winOverlay');
        winOverlay.style.display = 'none';
        
        // Stop big win sound and resume background music
        if (soundEffectsEnabled) {
            audioManager.stopSound(audioManager.sounds.win)
            // bigWinSound.pause();
            // bigWinSound.currentTime = 0;
            
            if (backgroundMusicEnabled) {
                if (isFreeSpinMode) {
                    freeSpinSound.play().catch(e => console.log("Audio play failed:", e));
                } else {
                    backgroundMusic.play().catch(e => console.log("Audio play failed:", e));
                }
            }
        }
        
        // Clear all coins
        const coinsContainer = document.getElementById('coinsContainer');
        coinsContainer.innerHTML = '';
    }


    // Stake button and overlay
    stakeButton.addEventListener('click', () => {
        if (!spinning && !isFreeSpinMode) {
            stakeOverlay.style.display = 'block';
            
            // Highlight the currently selected stake
            const stakeOptionButtons = stakeOptions.querySelectorAll('.option-button');
            stakeOptionButtons.forEach(button => {
                const value = parseFloat(button.dataset.value);
                if (value === stake) {
                    button.classList.add('selected');
                } else {
                    button.classList.remove('selected');
                }
            });
        }
    });



    // Display balance
    function displayBalance(amount) {
        const formattedAmount = parseFloat(amount).toLocaleString('en-US', {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
        balanceText.innerHTML = formattedAmount;
    }


    // Show features overlay
    function showFeaturesOverlay() {
        featuresOverlay.style.display = "block";
    }

    // Set demo feature
    function setDemoFeature(feature) {
        isFirstSpin = true; // Set first spin to trigger the passed feature
        currentDemoFeature.feature = feature;
        featuresOverlay.style.display = "none";
        spin();
    }

    // Show info overlay
    function showInfoOverlay() {
        hideSettingsOverlay();
        if (!spinning && !isFreeSpinMode) {
            infoOverlay.style.display = 'block';
        }
    }

    // Hide info overlay
    function hideInfoOverlay() {
        infoOverlay.style.display = 'none';
    }

    // Show stake overlay
    function showStakeOverlay() {
        if (!spinning && !isFreeSpinMode) {
            stakeOverlay.style.display = 'block';
            
            // Highlight the currently selected stake
            const stakeOptionButtons = stakeOptions.querySelectorAll('.option-button');
            stakeOptionButtons.forEach(button => {
                const value = parseFloat(button.dataset.value);
                if (value === stake) {
                    button.classList.add('selected');
                } else {
                    button.classList.remove('selected');
                }
            });
        }
    }

    // Hide stake overlay
    function hideStakeOverlay() {
        stakeOverlay.style.display = 'none';
    }

    // Confirm stake selection
    function confirmStake() {
        stake = selectedStake;
        currentStakeElement.textContent = stake.toFixed(1);
        stakeOverlay.style.display = 'none';
    }

    // Toggle auto play
    function toggleAutoPlay() {
        if (spinning && !isFreeSpinMode) {
            if (autoSpins > 0) {
                autoSpinsStopped = true;
                updateAutoSpinStatus();
                remainingAutoSpins.innerHTML = '';
                autoSpins = 0;
            }
        }
        else if (!spinning && !isFreeSpinMode) {
            if (autoSpins > 0) {
                // Cancel auto spins
                autoSpinsStopped = true;
                updateAutoSpinStatus();
                autoSpins = 0;
            } else {
                autoSpinOverlay.style.display = 'block';
                
                // Highlight the currently selected auto spins
                const autoSpinOptionButtons = autoSpinOptions.querySelectorAll('.option-button');
                autoSpinOptionButtons.forEach(button => {
                    const value = parseInt(button.dataset.value);
                    if (value === selectedAutoSpins) {
                        button.classList.add('selected');
                    } else {
                        button.classList.remove('selected');
                    }
                });
            }
        }
    }

    // Hide auto spin overlay
    function hideAutoSpinOverlay() {
        autoSpinOverlay.style.display = 'none';
    }

    // Confirm auto spin selection
    function confirmAutoSpin() {
        if (selectedAutoSpins > 0) {
            autoSpins = selectedAutoSpins;
            lossLimit = selectedLossLimit;
            initialBalance = balance; // Store initial balance to track losses
            autoSpinOverlay.style.display = 'none';
            autoSpinsStopped = false;
            updateAutoSpinStatus();
            spin();
        }
        else {
            updateAutoSpinStatus();
            autoSpinOverlay.style.display = 'none';
        }
    }

    // Update auto spin status
    function updateAutoSpinStatus() {
        if (autoSpinsStopped) {
            selectedAutoSpins = 0;
            const autoSpinOptionButtons = autoSpinOptions.querySelectorAll('.option-button');
            autoSpinOptionButtons.forEach(button => {
                if (button.classList.contains('selected')) {
                    button.classList.remove('selected');
                }
            });
            autoPlayButton.innerHTML = `<img src="autospininnerimg.png" class="autospininner-img" alt="">`;
        }
        else {
            autoPlayButton.innerHTML = `<img src="autospininnerimgstop.png" class="autospininnerimgstop"  alt="">`
        }
    }


    // Auto play button and overlay functionality
        autoPlayButton.addEventListener('click', () => {
            if (spinning && !isFreeSpinMode) {
                if (autoSpins > 0) {
                    autoSpinsStopped = true;
                    updateAutoSpinStatus();
                    remainingAutoSpins.innerHTML = '';
                    autoSpins = 0;
                }
            }
            else if (!spinning && !isFreeSpinMode) {
                if (autoSpins > 0) {
                    // Cancel auto spins
                    autoSpinsStopped = true;
                    updateAutoSpinStatus();
                    autoSpins = 0;
                } else {
                    autoSpinOverlay.style.display = 'block';
                    
                    // Highlight the currently selected auto spins
                    const autoSpinOptionButtons = autoSpinOptions.querySelectorAll('.option-button');
                    autoSpinOptionButtons.forEach(button => {
                        const value = parseInt(button.dataset.value);
                        if (value === selectedAutoSpins) {
                            button.classList.add('selected');
                        } else {
                            button.classList.remove('selected');
                        }
                    });
                }
            }
        });

        

    // Toggle quick spin
    function toggleQuickSpin() {
        isQuickSpinMode = !isQuickSpinMode;
        quickspinToggleImg.src = isQuickSpinMode ? 
            "quickspin-b.png" : 
            "quickspin-a.png";
    }

    // Display settings overlay

    function displaySettingsOverlay() {
        settingsOverlay.style.display = 'block';
    }

    // Hide settings overlay
    function hideSettingsOverlay() {
        settingsOverlay.style.display = 'none';
    }

    // Toggle background music
    function toggleBackgroundMusic() {
        const isEnabled = audioManager.toggleBackgroundMusic();
        
        if (isEnabled) {
            backgroundMusicIcon.innerHTML = `<i class="fa fa-volume-up" style="color: #e4d594; font-size: 1.4rem;"></i>`;
        } else {
            backgroundMusicIcon.innerHTML = `<i class="fas fa-volume-mute" style="color: #e4d594; font-size: 1.4rem;"></i>`;
        }
        
        settingsOverlay.style.display = 'none';
    }

    // Start free spins
    function startFreeSpins() {
        startFreeSpinsOverlay.style.display = "none";
        spin();
    }

    // Rotate spin button image
    function rotateSpinButtonImage() {
        spinButtonInnerImage.style.transition = 'transform 0.5s ease';
        spinButtonInnerImage.style.transform = 'rotate(180deg)';
    }

    // Reset spin button image
    function resetSpinButtonImage() {
        spinButtonInnerImage.style.transition = 'transform 0.5s ease';
        spinButtonInnerImage.style.transform = 'rotate(360deg)';
    }

    // New function to draw the game with new symbols instead of stopped reels
function drawGameWithNewSymbols() {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw the game in layers:
    // 1. Background
    drawBackground();
    
    // 2. All walls (drawn first, symbols will appear on top)
    drawWalls();
    
    // 3. Reel backgrounds
    drawReelBackgrounds();
    
    // 4. Draw spinning reels (these will appear to go under the bottom wall)
    drawSpinningReels();
    
    // 5. Draw reels with NEW symbols instead of stopped reels
    drawReelsWithNewSymbols();
    
    // 6. Win display (if there's a win)
    if (winAmount > 0 && !spinning) {
        drawWinDisplay();
    }
}

    // Function to draw reels with completely new random symbols
    function drawReelsWithNewSymbols() {
        const reelWidth = (canvas.width - WALL_THICKNESS.left - WALL_THICKNESS.right) / REEL_COUNT;
        const reelHeight = canvas.height - WALL_THICKNESS.top - WALL_THICKNESS.bottom;
        const symbolHeight = reelHeight / SYMBOLS_PER_REEL;
        
        // Draw reels with new symbols
        for (let i = 0; i < REEL_COUNT; i++) {
            // Only draw if this reel has stopped spinning
            try {
                if (reels[i].isSpinning) continue;
            } catch (error) {
                console.log('')
            }
            
            
            const reelX = WALL_THICKNESS.left + i * reelWidth;
            const reelY = WALL_THICKNESS.top;
            
            // Generate completely new symbols for this reel
            const newSymbols = [];
            for (let j = 0; j < SYMBOLS_PER_REEL; j++) {
                // For first reel (i === 0), exclude Wild from possible symbols
                let availableSymbols = i === 0 
                    ? SYMBOLS.filter(s => s.name !== 'Wild')
                    : SYMBOLS;
                
                const randomIndex = Math.floor(Math.random() * availableSymbols.length);
                const randomSymbolName = availableSymbols[randomIndex].name;
                
                newSymbols.push({
                    name: randomSymbolName,
                    isSpecial: Math.random() < 0.3,
                    scale: SYMBOL_SCALE_MAP[randomSymbolName] || 1.2
                });
            }
            
            // Draw the new symbols
            for (let j = 0; j < newSymbols.length; j++) {
                const symbol = newSymbols[j];
                const symbolData = SYMBOLS.find(s => s.name === symbol.name);
                
                // Calculate position - ensure exact positioning
                const symbolX = Math.round(reelX);
                const symbolY = Math.round(reelY + j * symbolHeight);
                
                // Draw symbol with new random symbol
                drawSymbol(symbolX, symbolY, reelWidth, symbolHeight, symbolData, symbol.isSpecial, symbol.scale);
            }
            
            // Optionally update the reel's finalSymbols to the new symbols
            // reels[i].finalSymbols = newSymbols;
        }
    }

    // Draw the game
    function drawGame() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw the game in layers:
        // 1. Background
        drawBackground();
        
        // 2. All walls (drawn first, symbols will appear on top)
        drawWalls();
        
        // 3. Reel backgrounds
        drawReelBackgrounds();
        
        // 4. Draw spinning reels (these will appear to go under the bottom wall)
        drawSpinningReels();
        
        // 5. Draw stopped reels (these will appear on top of all walls)
        drawStoppedReels();
        
        
        // 6. Win display (if there's a win)
        if (winAmount > 0 && !spinning) {
            drawWinDisplay();
        }
    }

    // Draw background
    function drawBackground() {
        ctx.fillStyle = isFreeSpinMode ? '#1a237e' : '#222222';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Define and load wall background images
const normalWallImages = [
    new Image(), // Top wall
    new Image(), // Right wall
    new Image(), // Bottom wall
    new Image()  // Left wall
];

const freeSpinWallImages = [
    new Image(), // Top wall
    new Image(), // Right wall
    new Image(), // Bottom wall
    new Image()  // Left wall
];

// Set image sources for normal walls
normalWallImages[0].src = 'wall-top.png';
normalWallImages[1].src = 'wall.png';
normalWallImages[2].src = 'resultsbcg3.png';
normalWallImages[3].src = 'wall.png';

// Set image sources for free spin walls (use different images)
freeSpinWallImages[0].src = 'freespin-wall-top.png'; // Replace with your free spin wall images
freeSpinWallImages[1].src = 'freespin-wall-right.png';
freeSpinWallImages[2].src = 'resultsbcg4.png';
freeSpinWallImages[3].src = 'freespin-wall-left.png';

// Preload all images before drawing walls
let normalWallImagesLoaded = 0;
let freeSpinWallImagesLoaded = 0;

normalWallImages.forEach((img) => {
    img.onload = () => {
        normalWallImagesLoaded++;
        if (normalWallImagesLoaded === normalWallImages.length) {
            drawWalls(); // Draw walls once all images are loaded
        }
    };
});

freeSpinWallImages.forEach((img) => {
    img.onload = () => {
        freeSpinWallImagesLoaded++;
    };
});

// Full drawWalls function using individual wall thicknesses
function drawWalls() {
    // Define positions and sizes for each wall
    const wallPositions = [
        { x: 0, y: 0, width: canvas.width, height: WALL_THICKNESS.top }, // Top - full width
        { x: canvas.width - WALL_THICKNESS.right, y: WALL_THICKNESS.top, width: WALL_THICKNESS.right, height: canvas.height - WALL_THICKNESS.top - WALL_THICKNESS.bottom }, // Right - between top and bottom
        { x: 0, y: canvas.height - WALL_THICKNESS.bottom, width: canvas.width, height: WALL_THICKNESS.bottom }, // Bottom - full width
        { x: 0, y: WALL_THICKNESS.top, width: WALL_THICKNESS.left, height: canvas.height - WALL_THICKNESS.top - WALL_THICKNESS.bottom }  // Left - between top and bottom
    ];

    // Select the appropriate wall images based on game mode
    const wallImages = isFreeSpinMode ? freeSpinWallImages : normalWallImages;
    const wallImagesLoaded = isFreeSpinMode ? freeSpinWallImagesLoaded : normalWallImagesLoaded;

    // Draw each wall using its corresponding color or image
    for (let i = 0; i < 4; i++) {
        const wall = wallPositions[i];
        ctx.fillStyle = WALL_BACKGROUNDS[i];
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
        
        // If wall images are loaded, draw them instead
        if (wallImagesLoaded === wallImages.length) {
            const image = wallImages[i];
            // Draw the image stretched to fit the wall area
            ctx.drawImage(image, wall.x, wall.y, wall.width, wall.height);
        }
    }
}

// Draw reel backgrounds
function drawReelBackgrounds() {
    const reelWidth = (canvas.width - WALL_THICKNESS.left - WALL_THICKNESS.right) / REEL_COUNT;
    const reelHeight = canvas.height - WALL_THICKNESS.top - WALL_THICKNESS.bottom;
    const symbolHeight = reelHeight / SYMBOLS_PER_REEL;

    // Draw background for reels area
    ctx.fillStyle = isFreeSpinMode ? '#1a237e' : '#000000';
    ctx.fillRect(
        WALL_THICKNESS.left, 
        WALL_THICKNESS.top, 
        reelWidth * REEL_COUNT, 
        reelHeight
    );

    // Create pattern from background image
    if (!window.reelBackgroundImage) {
        window.reelBackgroundImage = new Image();
        window.reelBackgroundImage.src = 'reel-bg.png'; // Use your background image path here
        window.reelBackgroundImage.onload = function() {
            drawGame(); // Redraw when image loads
        };
    }

    // Draw the background image across all reels
    if (window.reelBackgroundImage && window.reelBackgroundImage.complete) {
        // Draw the same background image for all reels
        for (let i = 0; i < REEL_COUNT; i++) {
            const reelX = WALL_THICKNESS.left + i * reelWidth;
            const reelY = WALL_THICKNESS.top;
            
            // Draw the background image
            ctx.drawImage(
                window.reelBackgroundImage,
                reelX, 
                reelY, 
                reelWidth, 
                reelHeight
            );
            
            // Draw left and right borders only
            ctx.strokeStyle = isFreeSpinMode ? '#d97800' : '#835318';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(reelX, reelY);                       // Left border start
            ctx.lineTo(reelX, reelY + reelHeight);          // Left border end
            ctx.moveTo(reelX + reelWidth, reelY);           // Right border start
            ctx.lineTo(reelX + reelWidth, reelY + reelHeight); // Right border end
            ctx.stroke();
        }
    } else {
        // Fallback if image isn't loaded yet
        for (let i = 0; i < REEL_COUNT; i++) {
            const reelX = WALL_THICKNESS.left + i * reelWidth;
            const reelY = WALL_THICKNESS.top;

            // Draw reel background
            ctx.fillStyle = isFreeSpinMode ? '#3e3424' : '#333333';
            ctx.fillRect(reelX, reelY, reelWidth, reelHeight);

            // Draw left and right borders only
            ctx.strokeStyle = isFreeSpinMode ? '#d97800' : '#835318';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(reelX, reelY);                       // Left border start
            ctx.lineTo(reelX, reelY + reelHeight);          // Left border end
            ctx.moveTo(reelX + reelWidth, reelY);           // Right border start
            ctx.lineTo(reelX + reelWidth, reelY + reelHeight); // Right border end
            ctx.stroke();
        }
    }
}

// Draw spinning reels
function drawSpinningReels() {
    const reelWidth = (canvas.width - WALL_THICKNESS.left - WALL_THICKNESS.right) / REEL_COUNT;
    const reelHeight = canvas.height - WALL_THICKNESS.top - WALL_THICKNESS.bottom;
    const symbolHeight = reelHeight / SYMBOLS_PER_REEL;
    
    // Create clipping region for spinning reels
    ctx.save();
    ctx.beginPath();
    ctx.rect(
        WALL_THICKNESS.left, 
        WALL_THICKNESS.top, 
        reelWidth * REEL_COUNT, 
        reelHeight
    );
    ctx.clip();
    
    // Draw spinning reels
    for (let i = 0; i < REEL_COUNT; i++) {
        // Only draw if this reel is still spinning
        if (!reels[i].isSpinning) continue;
        
        const reelX = WALL_THICKNESS.left + i * reelWidth;
        const reelY = WALL_THICKNESS.top;
        
        // Get the total number of symbols for this reel
        const totalSymbols = SYMBOLS_PER_REEL_ARRAY[i];
        
        // Calculate the current start position within the symbol array
        const currentPosition = reels[i].position;
        const startIndex = Math.floor(currentPosition / symbolHeight) % totalSymbols;
        const offsetY = currentPosition % symbolHeight; // Fractional position for smooth movement
        
        // Draw enough symbols to fill the view (including partially visible ones at top and bottom)
        const symbolsToShow = SYMBOLS_PER_REEL + 3; // Visible + partial at top and bottom
        
        // Make sure all symbols exist in the array
        if (!reels[i].hasInitializedSymbols) {
            // Initialize reel symbols array once
            reels[i].hasInitializedSymbols = true;
            
            // Create a full array of symbols that will act as our conveyor belt
            for (let j = 0; j < totalSymbols; j++) {
                if (!reels[i].symbols[j]) {
                    const randomIndex = Math.floor(Math.random() * SYMBOLS.length);
                    reels[i].symbols[j] = {
                        name: SYMBOLS[randomIndex].name,
                        isSpecial: Math.random() < 0.3,
                        scale: Math.random() * 0.5 + 1.1
                    };
                }
            }
        }
        
        // Draw the conveyor belt of symbols
        for (let j = -1; j < symbolsToShow; j++) {
            // Calculate the actual symbol index with wrapping for continuous flow
            const symbolIndex = (startIndex + j + totalSymbols) % totalSymbols;
            
            // Get the symbol from our existing array - we always show the same symbols in the same order
            const symbol = reels[i].symbols[symbolIndex];
            const symbolData = SYMBOLS.find(s => s.name === symbol.name);
            
            // Calculate the position for drawing the symbol with downward flow
            const symbolX = reelX;
            const symbolY = reelY + j * symbolHeight + offsetY;
            
            // Draw symbol, including partially visible ones at top and bottom
            drawSymbol(symbolX, symbolY, reelWidth, symbolHeight, symbolData, symbol.isSpecial, symbol.scale);
        }
        
        // Add a new symbol at the top of the conveyor during spinning
        // but only when we cross a symbol boundary, maintaining the conveyor belt effect
        if (Math.floor(reels[i].position / symbolHeight) !== Math.floor(reels[i].lastPosition / symbolHeight)) {
            // For downward flow, replace the symbol that's about to enter from the top
            const newSymbolIndex = (startIndex - 2 + totalSymbols) % totalSymbols;
            const randomIndex = Math.floor(Math.random() * SYMBOLS.length);
            reels[i].symbols[newSymbolIndex] = {
                name: SYMBOLS[randomIndex].name,
                isSpecial: Math.random() < 0.3,
                scale: Math.random() * 0.5 + 1.1
            };
        }
        
        // Store position for next frame
        reels[i].lastPosition = reels[i].position;
    }
    
    ctx.restore();
}

// Draw stopped reels
function drawStoppedReels() {
    const reelWidth = (canvas.width - WALL_THICKNESS.left - WALL_THICKNESS.right) / REEL_COUNT;
    const reelHeight = canvas.height - WALL_THICKNESS.top - WALL_THICKNESS.bottom;
    const symbolHeight = reelHeight / SYMBOLS_PER_REEL;
    
    // Draw stopped reels
    for (let i = 0; i < REEL_COUNT; i++) {
        // Only draw if this reel has stopped spinning
        try {
            if (reels[i].isSpinning) continue;
        } catch (error) {
            console.log('')
        }
        
        
        const reelX = WALL_THICKNESS.left + i * reelWidth;
        const reelY = WALL_THICKNESS.top;
        
        // Draw symbols
        for (let j = 0; j < reels[i].finalSymbols.length; j++) {
            const symbol = reels[i].finalSymbols[j];
            const symbolData = SYMBOLS.find(s => s.name === symbol.name);
            
            // Calculate position - ensure exact positioning
            // Use Math.round for all reels to ensure pixel-perfect alignment
            const symbolX = Math.round(reelX);
            const symbolY = Math.round(reelY + j * symbolHeight);
            
            // Special handling for the last reel to ensure perfect alignment
            if (i === REEL_COUNT - 1) {
                // Force exact positioning for the last reel
                reels[i].position = 0;
            }
            
            // Draw symbol
            drawSymbol(symbolX, symbolY, reelWidth, symbolHeight, symbolData, symbol.isSpecial, symbol.scale);
        }
    }
}



/**
 * Enhanced function to store the complete state before free spins are triggered
 * @param {Object} spinResult - The complete spin result object
 */
function storePreFreeSpinState(spinResult) {
    console.log('Storing pre-free spin state:', spinResult);
    
    // Create a deep copy of the spin result to avoid reference issues
    stoppedReelsPreFreeSpin = {
        reels: JSON.parse(JSON.stringify(spinResult.reels)),
        winningPositions: spinResult.winningPositions ? [...spinResult.winningPositions] : [],
        win: spinResult.win || 0,
        bonusMultiplier: spinResult.bonusMultiplier || 0,
        timestamp: Date.now(),
        // Store additional context that might be useful
        stake: stake,
        balance: balance,
        gameMode: gameMode.mode
    };
    
    console.log('Pre-free spin state stored successfully:', stoppedReelsPreFreeSpin);
}

/**
 * Function to redraw the symbols from before the free spins started
 * This will restore the exact reel configuration that was present when free spins were triggered
 */
function redrawPreFreeSpinSymbols() {
    console.log('Redrawing pre-free spin symbols...');
    
    // Check if we have stored state
    if (!stoppedReelsPreFreeSpin.reels) {
        console.warn('No pre-free spin state found to redraw');
        return false;
    }
    
    try {
        // Clear any active animations first
        activeAnimations = {};
        
        // Restore the original drawStoppedReels function if it was overridden
        if (typeof originalDrawStoppedReels === 'function') {
            drawStoppedReels = originalDrawStoppedReels;
        }
        
        // Restore the reel symbols to their pre-free spin state
        for (let i = 0; i < REEL_COUNT && i < stoppedReelsPreFreeSpin.reels.length; i++) {
            if (reels[i] && stoppedReelsPreFreeSpin.reels[i]) {
                // Deep copy the symbols to avoid reference issues
                reels[i].finalSymbols = JSON.parse(JSON.stringify(stoppedReelsPreFreeSpin.reels[i]));
                
                // Ensure the reel is not spinning
                reels[i].isSpinning = false;
                reels[i].position = 0;
            }
        }
        
        // Redraw the game with the restored symbols
        drawGame();
        
        // If there were winning positions, highlight them after a short delay
        if (stoppedReelsPreFreeSpin.winningPositions && stoppedReelsPreFreeSpin.winningPositions.length > 0) {
            setTimeout(() => {
                console.log('Highlighting pre-free spin winning positions:', stoppedReelsPreFreeSpin.winningPositions);
                highlightWinningSymbols(stoppedReelsPreFreeSpin.reels, stoppedReelsPreFreeSpin.winningPositions);
            }, 500);
        }
        
        console.log('Pre-free spin symbols redrawn successfully');
        return true;
        
    } catch (error) {
        console.error('Error redrawing pre-free spin symbols:', error);
        return false;
    }
}

/**
 * Function to clear the stored pre-free spin state
 * Call this when starting a new game session or when the stored state is no longer needed
 */
function clearPreFreeSpinState() {
    console.log('Clearing pre-free spin state');
    stoppedReelsPreFreeSpin = {
        reels: null,
        winningPositions: null,
        win: 0,
        bonusMultiplier: 0,
        timestamp: null
    };
}

// Draw a symbol
    function drawSymbol(x, y, width, height, symbol, isSpecial, scale = 1.2) {
        // Calculate center position
        const centerX = x + width / 2;
        const centerY = y + height / 2;

        // Save context for transformations
        ctx.save();
        
        // Check if symbol is defined, if not use a fallback
        if (!symbol) {
            console.warn('Undefined symbol encountered in drawSymbol');
            // Draw a fallback rectangle
            ctx.fillStyle = '#666666';
            ctx.fillRect(x, y, width, height);
            ctx.restore();
            return;
        }
        
        // Apply scaling transformation for special symbols
        if (2 > 1) {
            // Scale from 
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.translate(centerX, centerY);
            // Use a fallback scale if normal_scale is not defined
            const normalScale = symbol.normal_scale || scale || 1.2;
            ctx.scale(normalScale, normalScale);
            ctx.translate(-centerX, -centerY);
        }
        
        // Draw the symbol image
        // Draw the symbol image
        const img = symbolImages[symbol.name];
        if (img) {
            // Calculate image dimensions to fit within the symbol area
            const imgPadding = width * 0.05;
            const imgWidth = width - imgPadding * 2;
            const imgHeight = imgWidth * 1.16; // Make height 1.16 times the width
            
            // Draw the image
            ctx.drawImage(
                img, 
                x + (width - imgWidth) / 2, 
                y + (height - imgHeight) / 2, 
                imgWidth, 
                imgHeight
            );
        } else {
            // Fallback if image is not found
            ctx.fillStyle = symbol.color || '#999999';
            ctx.fillRect(
                x + width * 0.1, 
                y + height * 0.1, 
                width * 0.8, 
                height * 0.8
            );
            
            // Draw symbol name as text
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(symbol.name || 'Unknown', centerX, centerY);
        }
        
        // Restore context
        ctx.restore();
    }

// Update the highlightWinningSymbols function to handle the new winning positions format
function highlightWinningSymbols(reelSymbols, winningPositions) {
    // If no winning positions are passed, initialize it as an empty array
    winningPositions = winningPositions || [];
    
    console.log('------------Highlighting winning symbols----------------');
    console.log(winningPositions);
    
    // Track animation frames for scatter symbols
    const scatterFrames = {};
    const spriteScales = {};
    
    // Preload scatter animation frames
    const scatterFrameCount = 72;
    const scatterFrameImages = [];
    let loadedScatterFrames = 0;
    
    for (let i = 0; i <= scatterFrameCount; i++) {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
            loadedScatterFrames++;
        };
        img.src = `freespinframes/item_${i}.png`;
        scatterFrameImages.push(img);
    }
    
    // Clear previous animations when starting new ones
    activeAnimations = {};
    
    // Loop through winning positions and set up animations
    // The server response format has different structure
    winningPositions.forEach(pos => {
        // Create a unique key for this position
        const key = `${pos.reel}-${pos.row}`;
        
        activeAnimations[key] = {
            symbol: pos.symbol,
            reel: pos.reel,
            row: pos.row,
            startTime: Date.now(),
            active: true,
            // For scatter animations
            currentFrame: 0,
            direction: 1,
            lastUpdateTime: 0,
            frameRate: 25,
            // Different frame rates for different phases
            normalFrameRate: 25, // Normal animation frame rate (40 FPS)
            scaleUpFrameRate: 700 / 15, // 700ms for 15 frames (60-75) = ~46.67ms per frame
            scaleDownFrameRate: 500 / 75, // 500ms for 75 frames (75-0) = ~6.67ms per frame
            // New properties for scatter scaling behavior
            hasScaledUp: false, // Track if we've completed the scale up phase
            hasScaledDown: false, // Track if we've completed the scale down phase
            isInScaleUpPhase: false, // Track if currently in scale up phase (frames 60-75)
            isInScaleDownPhase: false, // Track if currently in scale down phase
            minScaleReached: false,
            // Scale values
            baseScale: 1.3, // Base scale when not in special phases
            maxScale: 1.5, // Maximum scale during scale up phase
            currentScale: 1.3, // Current scale value
        };
        
        // Initialize scale tracking for this symbol
        const spriteId = key;
        spriteScales[spriteId] = {
            originalScale: 1.0,
            currentScaleFactor: 1.0
        };
    });
    
    // Create animation frame function
    function animateWinningSymbols() {
        // Check if we have any active animations
        const hasActiveAnimations = Object.values(activeAnimations).some(anim => anim.active);
        
        if (!hasActiveAnimations) {
            return; // Stop animation loop if no active animations
        }
        
        // Redraw the game
        drawGame();
        
        // Request next frame
        requestAnimationFrame(animateWinningSymbols);
    }
    
    // Start animation loop
    if (Object.keys(activeAnimations).length > 0) {
        animateWinningSymbols();
    }
    
    // Override drawStoppedReels to include animations
    const originalDrawStoppedReels = drawStoppedReels;
    drawStoppedReels = function() {
        const reelWidth = (canvas.width - WALL_THICKNESS.left - WALL_THICKNESS.right) / REEL_COUNT;
        const reelHeight = canvas.height - WALL_THICKNESS.top - WALL_THICKNESS.bottom;
        const symbolHeight = reelHeight / SYMBOLS_PER_REEL;
        
        // Draw stopped reels
        for (let i = 0; i < REEL_COUNT; i++) {
            // Only draw if this reel has stopped spinning
            try {
                if (reels[i].isSpinning) continue;
            } catch (error) {
                console.log('');
            }
            
            
            const reelX = WALL_THICKNESS.left + i * reelWidth;
            const reelY = WALL_THICKNESS.top;
            
            // Draw symbols
            for (let j = 0; j < reels[i].finalSymbols.length; j++) {
                const symbol = reels[i].finalSymbols[j];
                const symbolData = SYMBOLS.find(s => s.name === symbol.name);
                
                // Calculate position
                const symbolX = reelX;
                const symbolY = reelY + j * symbolHeight;
                
                // Check if this symbol is being animated
                const animKey = `${i}-${j}`;
                const anim = activeAnimations[animKey];
                
                if (anim && anim.active) {
                    // Apply different animations based on symbol type
                    ctx.save();
                    
                    switch (anim.symbol) {
                        case "Scatter":
                            // Updated scatter animation - scale up to 75, down to 0, then loop 0-50
                            const now = Date.now()
                            if (now - anim.lastUpdateTime >= anim.frameRate) {
                                anim.lastUpdateTime = now

                                // Handle frame progression based on scaling completion status
                                if (anim.hasCompletedScaling) {
                                // After scaling is complete, only loop frames 0-50
                                anim.currentFrame += anim.direction
                                if (anim.currentFrame > 50) {
                                    anim.currentFrame = 0 // Jump back to start, stay within 0-50 range
                                } else if (anim.currentFrame < 0) {
                                    anim.currentFrame = 50 // Wrap around within 0-50 range
                                }
                                } else {
                                // Handle the scaling phases
                                if (!anim.isInScaleUpPhase && !anim.isInScaleDownPhase) {
                                    // Normal progression until frame 60
                                    anim.currentFrame += anim.direction

                                    if (anim.currentFrame === 60) {
                                    anim.isInScaleUpPhase = true
                                    console.log("Entering scale up phase at frame 60")
                                    }
                                } else if (anim.isInScaleUpPhase) {
                                    // Scale up phase: frames 60-75
                                    anim.currentFrame += anim.direction

                                    if (anim.currentFrame === 75) {
                                    anim.isInScaleUpPhase = false
                                    anim.isInScaleDownPhase = true
                                    anim.direction = -1 // Start going backwards
                                    console.log("Entering scale down phase at frame 75")
                                    }
                                } else if (anim.isInScaleDownPhase) {
                                    // Scale down phase: frames 75 down to 0
                                    anim.currentFrame += anim.direction // direction is -1, so this decreases

                                    if (anim.currentFrame === 0) {
                                    anim.isInScaleDownPhase = false
                                    anim.hasCompletedScaling = true
                                    anim.direction = 1 // Reset direction for normal looping
                                    anim.currentScale = anim.baseScale
                                    console.log("Scaling cycle complete - now looping frames 0-50 without scaling")
                                    }
                                }
                                }
                            }

                            // Calculate scale based on current phase
                            let scaleFactor = anim.baseScale // Default base scale

                            if (!anim.hasCompletedScaling) {
                                if (anim.isInScaleUpPhase && anim.currentFrame >= 60 && anim.currentFrame <= 75) {
                                // Scale up from frame 60 to 75 (15 frames)
                                const scaleProgress = (anim.currentFrame - 60) / 15 // 0 to 1
                                scaleFactor = anim.baseScale + (anim.maxScale - anim.baseScale) * scaleProgress
                                } else if (anim.isInScaleDownPhase && anim.currentFrame >= 0 && anim.currentFrame <= 75) {
                                // Scale down from frame 75 to 0 (75 frames)
                                const scaleProgress = anim.currentFrame / 75 // 1 to 0 (as frame goes from 75 to 0)
                                scaleFactor = anim.baseScale + (anim.maxScale - anim.baseScale) * scaleProgress
                                }
                            }
                            // If hasCompletedScaling is true, scaleFactor remains at baseScale (1.3)

                            anim.currentScale = scaleFactor

                            // Draw the current frame if it's loaded
                            if (loadedScatterFrames > anim.currentFrame) {
                                const frameImg = scatterFrameImages[anim.currentFrame]

                                // Calculate center position for scaling
                                const centerX = symbolX + reelWidth / 2
                                const centerY = symbolY + symbolHeight / 2

                                // Apply scaling from center
                                ctx.translate(centerX, centerY)
                                ctx.scale(scaleFactor, scaleFactor)
                                ctx.translate(-centerX, -centerY)

                                // Draw the frame
                                const imgPadding = reelWidth * 0.05
                                const imgSize = Math.min(reelWidth, symbolHeight) - imgPadding * 2
                                ctx.drawImage(
                                frameImg,
                                symbolX + (reelWidth - imgSize) / 2,
                                symbolY + (symbolHeight - imgSize) / 2,
                                imgSize,
                                imgSize * 1.1,
                                )
                            } else {
                                // Fallback to normal symbol if frames aren't loaded
                                drawSymbol(symbolX, symbolY, reelWidth, symbolHeight, symbolData, true, 1.3)
                            }
                            break
                        
                            // Other symbol animations remain the same...
                        
                        case "Treasure Chest":
                            // Blinking effect
                            if (Math.floor(Date.now() / 600) % 2 === 0) {
                                drawSymbol(symbolX, symbolY, reelWidth, symbolHeight, symbolData, true, 1.3);
                            }
                            break;
                            
                        case "Wild":
                            // Frame animation for Wild symbols
                            const wildNow = Date.now();
                            if (wildNow - anim.lastUpdateTime >= 75) { // 100ms frame rate
                                anim.lastUpdateTime = wildNow;
                                
                                // Update frame
                                anim.currentFrame += anim.direction;
                                
                                // Reverse direction at the ends
                                if (anim.currentFrame >= wildFrameCount) {
                                    anim.currentFrame = wildFrameCount - 2;
                                    anim.direction = -1;
                                } else if (anim.currentFrame < 0) {
                                    anim.currentFrame = 1;
                                    anim.direction = 1;
                                }
                            }
                            
                            // Calculate scale based on current frame position
                            const wildFrameProgress = anim.currentFrame / wildFrameCount;
                            const wildMaxScaleFactor = 1.75;
                            const wildScaleFactor = 1.5 + (wildMaxScaleFactor - 1.0) * wildFrameProgress;
                            
                            // Draw the current frame if it's loaded
                            if (loadedWildFrames > anim.currentFrame) {
                                const frameImg = wildFrameImages[anim.currentFrame];
                                
                                // Calculate center position for scaling
                                const centerX = symbolX + reelWidth / 2;
                                const centerY = symbolY + symbolHeight / 2;
                                
                                // Apply scaling from center
                                ctx.translate(centerX, centerY);
                                ctx.scale(wildScaleFactor, wildScaleFactor);
                                ctx.translate(-centerX, -centerY);
                                
                                // Draw the frame
                                const imgPadding = reelWidth * 0.05;
                                const imgSize = Math.min(reelWidth, symbolHeight) - imgPadding * 2;
                                ctx.drawImage(
                                    frameImg,
                                    symbolX + (reelWidth - imgSize) / 2,
                                    symbolY + (symbolHeight - imgSize) / 2,
                                    imgSize,
                                    imgSize
                                );
                            } else {
                                // Fallback to normal symbol if frames aren't loaded
                                drawSymbol(symbolX, symbolY, reelWidth, symbolHeight, symbolData, true, 1.3);
                            }
                            break;
                            
                        case "Explorer":
                        case "Compass":
                        case "Binoculars":
                            //blinking effect
                            if (Math.floor(Date.now() / 600) % 2 === 0) {
                                drawSymbol(symbolX, symbolY, reelWidth, symbolHeight, symbolData, true, 1.15);
                            }
                            break;
                            
                        case "A":
                        case "K":
                        case "Q":
                        case "J":
                            // Blinking effect
                            if (Math.floor(Date.now() / 600) % 2 === 0) {
                                drawSymbol(symbolX, symbolY, reelWidth, symbolHeight, symbolData, true, 1.15);
                            }
                            break;
                            
                        default:
                            // Default animation - pulsing
                            const defaultScale = 1.1 + 0.1 * Math.sin(Date.now() / 200);
                            drawSymbol(symbolX, symbolY, reelWidth, symbolHeight, symbolData, true, defaultScale);
                    }
                    
                    ctx.restore();
                } else {
                    // Draw normal symbol
                    drawSymbol(symbolX, symbolY, reelWidth, symbolHeight, symbolData, symbol.isSpecial, symbol.scale);
                }
            }
        }
    };
}


function generateMockResults() {
    const newResults = [];
    
    // Check if we should trigger free spins (10% chance if not already in free spin mode)
    const triggerFreeSpins = !isFreeSpinMode && (currentDemoFeature.feature === "free spins" || Math.random() < 0.1);
    
    // Check if we should generate a big win
    const generateBigWin = currentDemoFeature.feature === "big win" || Math.random() < 0.2;
    
    // If triggering free spins, ensure at least one scatter on each reel
    if (triggerFreeSpins) {
        for (let i = 0; i < REEL_COUNT; i++) {
            const reelSymbols = [];
            
            // Add one scatter symbol
            const scatterPosition = Math.floor(Math.random() * SYMBOLS_PER_REEL);
            
            for (let j = 0; j < SYMBOLS_PER_REEL; j++) {
                if (j === scatterPosition) {
                    reelSymbols.push({
                        name: 'Scatter',
                        isSpecial: true,
                        scale: 1.3
                    });
                } else {
                    // For first reel (i === 0), exclude Wild from possible symbols
                    let availableSymbols = i === 0 
                        ? SYMBOLS.filter(s => s.name !== 'Wild') 
                        : SYMBOLS;

                    
                    const randomIndex = Math.floor(Math.random() * availableSymbols.length);
                    reelSymbols.push({
                        name: availableSymbols[randomIndex].name,
                        isSpecial: Math.random() < 0.3,
                        scale: Math.random() * 0.5 + 1.1
                    });
                }
            }
            newResults.push(reelSymbols);
        }
    } 
    // If generating a big win, create a line of high-value symbols
    else if (generateBigWin) {
        // Choose a high-value symbol
        const highValueSymbols = ['Treasure Chest', 'Explorer', 'Compass', 'Binoculars'];
        const selectedSymbol = highValueSymbols[Math.floor(Math.random() * highValueSymbols.length)];
        
        // Create a line of matching symbols
        for (let i = 0; i < REEL_COUNT; i++) {
            const reelSymbols = [];
            
            for (let j = 0; j < SYMBOLS_PER_REEL; j++) {
                if (j === 1) { // Middle row for the winning line
                    if (i === 0) {
                        // First reel must have the selected symbol, not Wild
                        reelSymbols.push({
                            name: selectedSymbol,
                            isSpecial: true,
                            scale: 1.2
                        });
                    } else {
                        // Other reels can have Wild or the selected symbol
                        reelSymbols.push({
                            name: Math.random() < 0.7 ? selectedSymbol : 'Wild',
                            isSpecial: true,
                            scale: 1.2
                        });
                    }
                } else {
                    // For first reel (i === 0), exclude Wild from possible symbols
                    let availableSymbols = i === 0 
                        ? SYMBOLS.filter(s => s.name !== 'Wild')
                        : SYMBOLS;
                    
                    const randomIndex = Math.floor(Math.random() * availableSymbols.length);
                    reelSymbols.push({
                        name: availableSymbols[randomIndex].name,
                        isSpecial: Math.random() < 0.3,
                        scale: Math.random() * 0.5 + 1.1
                    });
                }
            }
            newResults.push(reelSymbols);
        }
    }
    // Normal results
    else {
        for (let i = 0; i < REEL_COUNT; i++) {
            const reelSymbols = [];
            for (let j = 0; j < SYMBOLS_PER_REEL; j++) {
                // For first reel (i === 0), exclude Wild from possible symbols
                let availableSymbols = i === 0 
                    ? SYMBOLS.filter(s => s.name !== 'Wild')
                    : SYMBOLS;
                
                const randomIndex = Math.floor(Math.random() * availableSymbols.length);
                reelSymbols.push({
                    name: availableSymbols[randomIndex].name,
                    isSpecial: Math.random() < 0.3,
                    scale: Math.random() * 0.5 + 1.1
                });
            }
            newResults.push(reelSymbols);
        }
    }
    
    return {
        reels: newResults,
        triggerFreeSpins: triggerFreeSpins,
        generateBigWin: generateBigWin
    };
}

    // Add a new function to send requests to the server for spin results
// Add this after the calculateWinAmount function
// Update the fetchSpinResultsFromServer function to use the transformServerResponse function

function fetchSpinResultsFromServer(payload) {
    console.log(payload)
    // Create the request payload
    const API_BASE_URL = "https://b.api.ibibe.africa";
    
    // Return a promise that resolves with the spin results
    return fetch(`${API_BASE_URL}/spin/kong`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload)
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(data => {
        console.log("Server response:", data);
        
        // Use the transformServerResponse function to format the data
        const transformedData = transformServerResponse(data);
        
        if (!transformedData) {
            throw new Error('Failed to transform server response');
        }
        
        return transformedData;
    })
    .catch(error => {
        console.error('Error fetching spin results:', error);
        // Fallback to local generation in case of error
        const mockResults = generateMockResults();
        const winResult = calculateWinAmount(mockResults, isFreeSpinMode, bonusMultiplier);
        return {
            reels: mockResults.reels,
            win: winResult.amount,
            winningPositions: winResult.positions,
            triggerFreeSpins: mockResults.triggerFreeSpins
        };
    });
}

// Add a function to show a loading indicator if the server response takes too long
function showLoadingIndicator() {
    const loadingIndicator = document.createElement('div');
    loadingIndicator.id = 'server-loading-indicator';
    loadingIndicator.style.position = 'absolute';
    loadingIndicator.style.top = '50%';
    loadingIndicator.style.left = '50%';
    loadingIndicator.style.transform = 'translate(-50%, -50%)';
    loadingIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
    loadingIndicator.style.color = 'white';
    loadingIndicator.style.padding = '10px 20px';
    loadingIndicator.style.borderRadius = '5px';
    loadingIndicator.style.zIndex = '1000';
    loadingIndicator.style.display = 'none';
    loadingIndicator.innerHTML = 'Waiting for server...';
    
    document.querySelector('.game-canvas-container').appendChild(loadingIndicator);
    
    // Show the indicator after a delay if the server hasn't responded
    setTimeout(() => {
        const indicator = document.getElementById('server-loading-indicator');
        if (indicator) {
            indicator.style.display = 'block';
        }
    }, 3000); // Show after 3 seconds
}

function hideLoadingIndicator() {
    const indicator = document.getElementById('server-loading-indicator');
    if (indicator) {
        indicator.remove();
    }
}


function calculateWinAmount(results, isFreeSpinMode, bonusMultiplier) {
    // Extract symbol names from results for easier processing
    const symbolNames = results.reels.map(reel => 
        reel.map(symbol => symbol.name)
    );
    
    // Check for winning combinations
    let totalWin = 0;
    let winningPositions = [];
    
    // Check for matching symbols on each row
    for (let row = 0; row < SYMBOLS_PER_REEL; row++) {
        // Check each symbol (except Scatter which pays anywhere)
        for (let symbolObj of SYMBOLS) {
            if (symbolObj.name === 'Scatter') continue;
            
            let count = 0;
            let positions = [];
            
            // Count consecutive matching symbols from left to right
            for (let reel = 0; reel < REEL_COUNT; reel++) {
                const currentSymbol = symbolNames[reel][row];
                
                // Match if same symbol or Wild (except first reel)
                if (currentSymbol === symbolObj.name || (currentSymbol === 'Wild' && reel > 0)) {
                    count++;
                    positions.push({ reel, row, symbol: currentSymbol });
                } else {
                    break;
                }
            }
            
            // Check if we have a win (3 or more matching symbols)
            if (count >= 3) {
                // Get payout for this symbol and count
                const payout = symbolObj.payouts[count];
                
                // Calculate win amount
                let win = payout * stake;
                
                // Apply bonus multiplier in free spin mode
                if (isFreeSpinMode && bonusMultiplier > 0) {
                    win *= bonusMultiplier;
                }
                
                totalWin += win;
                winningPositions = winningPositions.concat(positions);
            }
        }
    }
    
    // Check for Scatter wins - only if in free spin mode
    if (isFreeSpinMode) {
        let scatterCount = 0;
        let scatterPositions = [];
        
        for (let reel = 0; reel < REEL_COUNT; reel++) {
            for (let row = 0; row < SYMBOLS_PER_REEL; row++) {
                if (symbolNames[reel][row] === 'Scatter') {
                    scatterCount++;
                    scatterPositions.push({ reel, row, symbol: 'Scatter' });
                }
            }
        }
        
        // Scatter pays anywhere if in free spin mode
        if (scatterCount >= 3) {
            const scatterObj = SYMBOLS.find(s => s.name === 'Scatter');
            const payout = scatterObj.payouts[scatterCount] || 0;
            
            let win = payout * stake;
            
            // Apply bonus multiplier
            if (bonusMultiplier > 0) {
                win *= bonusMultiplier;
            }
            
            totalWin += win;
            winningPositions = winningPositions.concat(scatterPositions);
        }
    } else {
        // If not in free spin mode, still count scatters for triggering free spins
        // but don't add them to winning positions for animation
        let scatterCount = 0;
        
        for (let reel = 0; reel < REEL_COUNT; reel++) {
            for (let row = 0; row < SYMBOLS_PER_REEL; row++) {
                if (symbolNames[reel][row] === 'Scatter') {
                    scatterCount++;
                }
            }
        }
        
        // Check if we should trigger free spins (at least one scatter on each reel)
        if (scatterCount >= REEL_COUNT) {
            results.triggerFreeSpins = true;
            
            // Add scatter positions for animation when triggering free spins
            let scatterPositions = [];
            for (let reel = 0; reel < REEL_COUNT; reel++) {
                for (let row = 0; row < SYMBOLS_PER_REEL; row++) {
                    if (symbolNames[reel][row] === 'Scatter') {
                        scatterPositions.push({ reel, row, symbol: 'Scatter' });
                    }
                }
            }
            
            // Add scatter positions to winning positions for animation
            winningPositions = winningPositions.concat(scatterPositions);
        }
    }
    
    // If it's a big win demo, ensure a big win
    if (results.generateBigWin && totalWin < 100) {
        totalWin = 100 + Math.floor(Math.random() * 400);
    }
    
    // If we have winning positions, highlight them
    if (winningPositions.length > 0) {
        highlightWinningSymbols(results.reels, winningPositions);
    }
    
    return {
        amount: totalWin,
        positions: winningPositions
    };
}


// Animation function for spinning reels
async function spin() {
    removeBonusFrameFromLastReel()
    anySymbolConsecutive = false

    document.getElementById('display_win_amount').style.display = 'none';

    if (spinning || (balance < stake && !isFreeSpinMode)) return;

    // Check if loss limit has been reached
    if (autoSpins > 0 && !isFreeSpinMode) {
        const currentLoss = initialBalance - balance;
        const maxAllowedLoss = lossLimit === Infinity ? Infinity : stake * lossLimit;
        
        if (currentLoss >= maxAllowedLoss && maxAllowedLoss !== Infinity) {
            autoSpinsStopped = true;
            updateAutoSpinStatus();
            remainingAutoSpins.innerHTML = '';
            autoSpins = 0;
            alert(`Auto-spins stopped: Loss limit of ${maxAllowedLoss.toFixed(2)} reached.`);
            return;
        }
    } 
    
    if (stake <= 0 || (stake > balance && !isFreeSpinMode)) {
        alert("Invalid stake amount!");
        return;
    }

    // Stop any active animations by clearing the activeAnimations object
    activeAnimations = {};
    
    // Restore original drawStoppedReels function if it was overridden
    if (typeof originalDrawStoppedReels === 'function') {
        drawStoppedReels = originalDrawStoppedReels;
    }

    // Rotate the spin button image before spinning
    rotateSpinButtonImage();

    // Deduct bet amount if not in free spin mode
    if (!isFreeSpinMode) {
        async function placeAndHandleBet(stake) {
            try {
                const place_bet_response = await placeBet(stake);
                console.log(place_bet_response);
                balance -= stake;
                displayBalance(balance);
            } catch (error) {
                console.error("Error placing bet:", error);
            }
        }

        await placeAndHandleBet(stake)
    }

    // Play spin sound if enabled
    if (soundEffectsEnabled) {
        spinSound.play().catch(e => console.log("Audio play failed:", e));
    }
    
    spinning = true;
    featuresButton.disabled = true;

    // Hide win message
    winMessageElement.style.display = 'none';
    if (!isFreeSpinMode){
        document.getElementById('update_winnings').innerHTML = '0.00';
    }

    // Prepare reels for spinning
    for (let i = 0; i < REEL_COUNT; i++) {
        // Reset position
        reels[i].position = 0;
        
        // Set spinning state
        reels[i].isSpinning = true;
        reels[i].lastPosition = 0;
        
        // Generate a full conveyor belt of symbols for smooth scrolling
        const totalSymbols = SYMBOLS_PER_REEL_ARRAY[i];
        reels[i].symbols = [];
        
        // Create a continuous belt of random symbols
        for (let j = 0; j < totalSymbols; j++) {
            const randomIndex = Math.floor(Math.random() * SYMBOLS.length);
            reels[i].symbols.push({
                name: SYMBOLS[randomIndex].name,
                isSpecial: Math.random() < 0.3,
                scale: Math.random() * 0.5 + 1.1
            });
        }
    }

    // Get spin results based on game mode
    let apiResult;
    let animationController = { 
        hasResults: false, 
        results: null,
        reelsStoppedCount: 0,
        allReelsStopped: false
    };
  
    // Function to update the animation with results
    function updateSpinningReelsWithResults(results) {
        console.log("Updating spinning reels with results:", results);
        animationController.hasResults = true;
        animationController.results = results;
    }
    
    if (gameMode.mode === 'live') {
        // In live mode, fetch results from server
        showLoadingIndicator(); // Show loading indicator if server takes too long

        const payload = {
            client_id: gameInfo.client_id,
            game_id: gameInfo.game_id,
            player_id: playerInfo.id,
            bet_id: lastPlacedBetData.bet_id,
            bet_amount: isFreeSpinMode ? 0 : stake,
            is_free_spin: isFreeSpinMode,
            free_spin_count: freeSpinCount,
            bonus_multiplier: bonusMultiplier,
            original_bet_amount: isFreeSpinMode ? originalBetAmount : 0
        };
        
        try {
            // Start spinning animation while waiting for server response
            const spinPromise = new Promise(resolve => {
                spinAnimation(() => {
                    // This callback won't be called until we have results
                    resolve();
                }, null); // Pass null to indicate we're waiting for results
            });
            
            // Fetch results from server
            apiResult = await fetchSpinResultsFromServer(payload);
            console.log("API returned results:", apiResult);
            hideLoadingIndicator();
            
            // Update the spinning animation with the actual results
            updateSpinningReelsWithResults(apiResult);
            
            // Wait for spinning animation to complete
            await spinPromise;
        } catch (error) {
            console.error('Error in live mode spin:', error);
            hideLoadingIndicator();
            
            // Fallback to local generation
            const mockResults = generateMockResults();
            const winResult = calculateWinAmount(mockResults, isFreeSpinMode, bonusMultiplier);
            apiResult = {
                reels: mockResults.reels,
                win: winResult.amount,
                winningPositions: winResult.positions,
                triggerFreeSpins: mockResults.triggerFreeSpins
            };
            
            // Update with fallback results
            updateSpinningReelsWithResults(apiResult);
        }
    } else {
        // In demo mode, generate results locally
        const mockResults = generateMockResults();
        const winResult = calculateWinAmount(mockResults, isFreeSpinMode, bonusMultiplier);
        apiResult = {
            reels: mockResults.reels,
            win: winResult.amount,
            winningPositions: winResult.positions,
            triggerFreeSpins: mockResults.triggerFreeSpins
        };
        
        // Start spin animation with local results
        spinAnimation(() => {
            handleSpinCompletion(apiResult);
        }, apiResult);
    }
}


// Function to update spinning reels with server results
function updateSpinningReelsWithResults(apiResult) {
    // This function is called when server results arrive while reels are still spinning
    // It updates the animation to ensure it will stop with the correct results
    
    // If we don't have valid results, do nothing
    if (!apiResult || !apiResult.reels) return;
    
    // Update each reel's final symbols
    for (let i = 0; i < REEL_COUNT; i++) {
        if (apiResult.reels[i]) {
            reels[i].finalSymbols = apiResult.reels[i];
        }
    }
}

// Function to handle spin completion and process results
function handleSpinCompletion(apiResult) {
    // Process win amount
    if (apiResult.win > 0) {
        // Update balance with winnings
        balance += apiResult.win;
        console.log(`New Balance after win: ${balance}`)
        if (!isFreeSpinMode){
            displayBalance(balance);
        }
        
        // Display win amount
        document.getElementById('display_win_amount').style.display = 'block';
        if (!isFreeSpinMode){
            document.getElementById('update_winnings').innerHTML = apiResult.win.toFixed(2);
        }
        
        // Show win message
        winMessageElement.style.display = 'block';
        winMessageElement.innerHTML = `Win: ${apiResult.win.toFixed(2)}`;
        
        // Highlight winning positions
        highlightWinningPositions(apiResult.winningPositions);
        
        // Play win sound if enabled
        if (soundEffectsEnabled) {
            console.log('')
            // const winningSound = new Audio("sounds/SE_Scoring_01.mp3");
            // winningSound.volume = 0.9;
            // stopsoundund.currentTime = 0; // Start from the 4th second
            // stopsoundund.play().catch(e => console.log("Audio play failed:", e));
        }
    }
    
    // Handle free spins if triggered
    if (apiResult.triggerFreeSpins && !isFreeSpinMode) {
        startFreeSpins(apiResult.freeSpinCount || 10, apiResult.bonusMultiplier || 2);
    }
    
    // Handle free spin count if in free spin mode
    if (isFreeSpinMode) {
        freeSpinCount--;
        updateFreeSpinDisplay();
        
        if (freeSpinCount <= 0) {
            endFreeSpins();
        } else {
            // Auto-trigger next free spin after a delay
            setTimeout(() => {
                if (!spinning) spin();
            }, 2000);
        }
    }
    
    // Handle auto-spins
    if (autoSpins > 0 && !isFreeSpinMode) {
        autoSpins--;
        updateAutoSpinStatus();
        
        if (autoSpins > 0) {
            // Trigger next auto-spin after a delay
            if (apiResult.win > 0){
                setTimeout(() => {
                    if (!spinning) spin();
                }, 3000);
            } else {
                setTimeout(() => {
                    if (!spinning) spin();
                }, 2000);
            }
            
        } else {
            remainingAutoSpins.innerHTML = '';
        }
    }
}

// Function to highlight winning positions on the reels
function highlightWinningPositions(positions) {
    if (!positions || positions.length === 0) return;
    
    // Store the original draw function if not already stored
    if (!originalDrawStoppedReels) {
        originalDrawStoppedReels = drawStoppedReels;
    }
    
    // Override the draw function to add highlighting
    drawStoppedReels = function(ctx) {
        // Call the original function first
        originalDrawStoppedReels(ctx);
        
        // Then add highlighting for winning positions
        ctx.save();
        
        // Calculate symbol dimensions
        const reelWidth = (canvas.width - WALL_THICKNESS.left - WALL_THICKNESS.right) / REEL_COUNT;
        const reelHeight = (canvas.height - WALL_THICKNESS.top - WALL_THICKNESS.bottom);
        const symbolHeight = reelHeight / SYMBOLS_PER_REEL;
        
        // Draw highlight for each winning position
        for (const pos of positions) {
            const reelIndex = pos.reel;
            const symbolIndex = pos.position;
            
            const x = WALL_THICKNESS.left + reelIndex * reelWidth;
            const y = WALL_THICKNESS.top + symbolIndex * symbolHeight;
            
            // Create highlight effect
            ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.fillRect(x, y, reelWidth, symbolHeight);
            
            // Add glowing border
            ctx.strokeStyle = 'gold';
            ctx.lineWidth = 3;
            ctx.strokeRect(x + 2, y + 2, reelWidth - 4, symbolHeight - 4);
            
            // Add pulsing animation
            const pulseTime = Date.now() % 1000 / 1000;
            const pulseOpacity = 0.3 + Math.sin(pulseTime * Math.PI * 2) * 0.2;
            
            ctx.fillStyle = `rgba(255, 255, 0, ${pulseOpacity})`;
            ctx.fillRect(x + 5, y + 5, reelWidth - 10, symbolHeight - 10);
        }
        
        ctx.restore();
    };
    
    // Create animation for the winning effect
    const animationId = 'winHighlight';
    activeAnimations[animationId] = {
        duration: 5000, // 5 seconds of highlighting
        startTime: Date.now(),
        onUpdate: function() {
            // Just trigger a redraw
            drawGame();
        },
        onComplete: function() {
            // Restore original draw function
            drawStoppedReels = originalDrawStoppedReels;
            drawGame();
            delete activeAnimations[animationId];
        }
    };
    
    // Start animation loop if not already running
    if (!animationLoopRunning) {
        animationLoopRunning = true;
        requestAnimationFrame(updateAnimations);
    }
}

// Animation loop for effects
function updateAnimations(timestamp) {
    const currentTime = Date.now();
    let hasActiveAnimations = false;
    
    // Update all active animations
    for (const id in activeAnimations) {
        const anim = activeAnimations[id];
        const elapsed = currentTime - anim.startTime;
        
        if (elapsed < anim.duration) {
            // Animation still running
            hasActiveAnimations = true;
            anim.onUpdate(elapsed / anim.duration);
        } else {
            // Animation complete
            anim.onComplete();
            delete activeAnimations[id];
        }
    }
    
    // Continue animation loop if there are active animations
    if (hasActiveAnimations) {
        requestAnimationFrame(updateAnimations);
    } else {
        animationLoopRunning = false;
    }
}

// Add a function to update spinning reels with server results
function updateSpinningReelsWithResults(results) {
    // Make sure we have valid results
    if (!results || !results.reels) {
        console.error("Invalid results in updateSpinningReelsWithResults:", results);
        return;
    }
    
    // Process each reel
    for (let i = 0; i < Math.min(REEL_COUNT, results.reels.length); i++) {
        // Make sure the reel exists
        if (!reels[i]) {
            console.warn(`Reel ${i} does not exist`);
            continue;
        }
        
        // Update the final symbols for this reel
        reels[i].finalSymbols = results.reels[i];
    }
    
    // Signal to the spinning animation that we have results
    if (currentInterval) {
        clearInterval(currentInterval);
        
        // Start a new spin animation with the actual results
        spinAnimation(() => {
            handleSpinCompletion(results);
        }, results);
    }
}


let winValueDisplayInterval = null; // holds the interval ID globally

function groupWinValuesDisplay(spinResults) { 
    console.log('Entered ----------------------------------------');

    if (spinResults.length > 0) {
        document.getElementById('display_win_amount').style.display = 'block';
    }

    // Clear previous interval
    if (winValueDisplayInterval !== null) {
        clearInterval(winValueDisplayInterval);
        winValueDisplayInterval = null;
    }

    const winValuesGroupedByWay = {};
    const displayItems = [];

    // Group results by 'ways'
    for (let i = 0; i < spinResults.length; i++) {
        const result = spinResults[i];
        const way = result.ways;

        if (!winValuesGroupedByWay[way]) {
            winValuesGroupedByWay[way] = [];
        }

        winValuesGroupedByWay[way].push(result);
    }

    for (const way in winValuesGroupedByWay) {
        const results = winValuesGroupedByWay[way];

        // Count how many times each row appears
        const rowCounts = {};
        for (const res of results) {
            if (!rowCounts[res.row]) {
                rowCounts[res.row] = 0;
            }
            rowCounts[res.row]++;
        }

        // Find all rows with the maximum count
        let maxCount = 0;
        for (const count of Object.values(rowCounts)) {
            if (count > maxCount) {
                maxCount = count;
            }
        }

        const candidateRows = Object.keys(rowCounts).filter(row => rowCounts[row] === maxCount).map(Number);

        // Check if any of these candidate rows have a symbol on reel 3 (index 2)
        let bestRow = null;
        for (const row of candidateRows) {
            const hasMiddleReelSymbol = results.some(res => res.row === row && res.reel === 2);
            if (hasMiddleReelSymbol) {
                bestRow = row;
                break;
            }
        }

        // If no candidate row has symbol in middle reel, choose any that does
        if (bestRow === null) {
            const withMiddleReel = results.find(res => res.reel === 2);
            if (withMiddleReel) {
                bestRow = withMiddleReel.row;
            } else {
                bestRow = candidateRows[0]; // fallback to first candidate
            }
        }

        // Collect unique win values for this best row
        const seen = new Set();
        for (const res of results) {
            if (!seen.has(res.win_value)) {
                seen.add(res.win_value);
                displayItems.push({
                    win_value: res.win_value,
                    row: bestRow
                });
            }
        }
    }

    // Display logic
    if (displayItems.length === 1) {
        const row = displayItems[0].row;
        const winEl = document.getElementById('win-amount2');

        winEl.style.marginTop = row === 1 ? '22%' : row === 2 ? '45%' : '0%';
        winEl.innerHTML = parseFloat(displayItems[0].win_value).toFixed(2);
        return;
    }

    let currentIndex = 0;

    winValueDisplayInterval = setInterval(() => {
        if (!isFreeSpinMode) {
            const currentItem = displayItems[currentIndex];
            const winEl = document.getElementById('win-amount2');

            winEl.style.marginTop = currentItem.row === 1 ? '22%' :
                                    currentItem.row === 2 ? '45%' : '0%';

            winEl.innerHTML = parseFloat(currentItem.win_value).toFixed(2);
        }

        currentIndex = (currentIndex + 1) % displayItems.length;
    }, 2000);
}


function updateWinnings(targetAmount) {
    let element = document.getElementById('update_winnings');
    let currentAmount = 0;
    let increment = (targetAmount - currentAmount) / 50; // Adjust speed
    const winningSound = new Audio("sounds/SE_Scoring_01.mp3");
    if (soundEffectsEnabled){
        winningSound.volume = 0.9;
        winningSoundcurrentTime = 0; // Start from the 4th second
        winningSound.play().catch(e => console.log("Audio play failed:", e));
    }

    let progressByLastSpin = accumulatedAmountDuringFreespin;

    let counter = setInterval(() => {
        currentAmount += increment;
        if (!isFreeSpinMode){
            element.innerHTML = `${(currentAmount + progressByLastSpin).toFixed(2)}`;
        } else if (freeSpinEndedRecently === true){
            element.innerHTML = `${(currentAmount + progressByLastSpin).toFixed(2)}`;
            freeSpinEndedRecently = false;
        }
        else {
            element.innerHTML = `${(currentAmount + progressByLastSpin).toFixed(2)}`;
        }
        

        if ((increment > 0 && currentAmount >= targetAmount) || (increment < 0 && currentAmount <= targetAmount)) {
            if (!isFreeSpinMode){
                element.innerHTML = `${(targetAmount + progressByLastSpin).toFixed(2)}`;
            }
            clearInterval(counter);
            if (soundEffectsEnabled){
                winningSound.pause()
            }
            
            if (!isFreeSpinMode){
                displayBalance(balance)
            }
        }
    }, 20); // Update every 20ms

    if (isFreeSpinMode || freeSpinEndedRecently){
        accumulatedAmountDuringFreespin += targetAmount;
    }

    
}

    function getWinLevel(amount) {
            if (amount < winLevels.big.threshold) {
            return 'big';
            } else if (amount < winLevels.mega.threshold) {
            return 'mega';
            } else {
            return 'ultra';
            }
      }

// Function to show the win animation
      function showWinAnimation(amount) {
        // do not show big win animation during free spins
        if (autoSpins > 0 || isFreeSpinMode){
            return
        }
        // Reset any existing animations
        clearTimeout(window.autoCloseTimeout);
        
        // Set initial win level
        let currentLevel = 'big';
        document.getElementById('winImg').src = "winlevels/bigwin.png";
        updateWinLevel(currentLevel);
        
        // Show the overlay
        const winOverlay = document.getElementById('winOverlay');
        winOverlay.style.display = 'flex';

        if (soundEffectsEnabled){
            audioManager.playSound(audioManager.sounds.win)
        }
        // Start with $0
        let currentAmount = 0;
        const winAmount = document.getElementById('winAmount');
        winAmount.textContent = '$' + currentAmount.toLocaleString();
        
        // Create the coin fountain
        setTimeout(() => {
          createCoinFountain(winLevels[currentLevel].coinCount);
        }, 200);
        
        // Animate the counter
        const duration = 7000; // 7 seconds for the counter
        const fps = 60;
        const increment = amount / (duration / 1000 * fps);
        const startTime = performance.now();
        
        function updateCounter(timestamp) {
          const elapsed = timestamp - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          currentAmount = progress * amount;
          winAmount.textContent = '$' + Math.floor(currentAmount).toLocaleString();
          
          // Check if we need to upgrade the win level
          const newLevel = getWinLevel(currentAmount);
          if (newLevel !== currentLevel) {
            currentLevel = newLevel;
            updateWinLevel(currentLevel);
            
            // Add more coins for the new level
            createCoinFountain(winLevels[currentLevel].coinCount);
          }
          
          if (progress < 1) {
            requestAnimationFrame(updateCounter);
          } else {
            // Counter finished
            winAmount.textContent = '$' + amount.toLocaleString();
            
            // Auto close after 3 seconds
            window.autoCloseTimeout = setTimeout(() => {
              closeWinAnimation();
            }, 7000);
          }
        }
        
        requestAnimationFrame(updateCounter);
      }



let anySymbolConsecutive = false;

function checkConsecutiveSymbols(reels) {
    console.log('Checking consecutive symbols:', reels);
    
    // Reset the global variable
    anySymbolConsecutive = false;
    
    // Get all unique symbols (excluding wild)
    const allSymbols = new Set();
    reels.forEach(reel => {
        reel.forEach(symbol => {
            allSymbols.add(symbol.name);
        });
    });
    
    // Check each symbol for consecutive appearance
    for (const symbolName of allSymbols) {
        if (isSymbolConsecutive(reels, symbolName)) {
            console.log(`Symbol "${symbolName}" appears consecutively across all reels`);
            anySymbolConsecutive = true;
            break; // Found at least one consecutive symbol
        }
    }
    
    console.log('Any symbol consecutive:', anySymbolConsecutive);
    return anySymbolConsecutive;
}

function isSymbolConsecutive(reels, targetSymbol) {
    // Check if the target symbol appears in each reel (with wild substitution)
    for (let reelIndex = 0; reelIndex < reels.length - 1; reelIndex++) {
        const reel = reels[reelIndex];
        let symbolFound = false;
        
        // Check each position in the current reel 
        for (let row = 0; row < reel.length; row++) {
            const symbol = reel[row];
            if (symbol.name === targetSymbol) {
                symbolFound = true;
                break;
            }
        }
        
        // If symbol not found in this reel, it's not consecutive
        if (!symbolFound) {
            return false;
        }
    }
    
    return true; // Symbol found in all reels
}



function extractScatterPositions(reels) {

    console.log(reels)


    const results = [];

    for (let reel = 0; reel < reels.length; reel++) {
        for (let row = 0; row < reels[reel].length; row++) {
            const symbol = reels[reel][row];
            if (symbol.name === "Scatter") {
                console.log('Pushing Scatter')
                results.push({
                    symbol: "Scatter",
                    reel: reel,
                    row: row,
                    count: 0,       // placeholder
                    ways: 0,        // placeholder
                    win_value: 0.0  // placeholder
                });
            }
        }
    }

    return results;
}
    

      


// Extract the spin completion handling to a separate function
function handleSpinCompletion(apiResult) {
    // Reset the spin button image after animation completes
    resetSpinButtonImage();

    // Update win amount
    if (apiResult.win > 0) {
        // Update balance with winnings
        balance += apiResult.win;
        updateWinnings(apiResult.win);

        // Play win sound using audio manager
        audioManager.playWinSound(apiResult.win);
        
        // Show big win animation for large wins
        if (apiResult.win >= 100 && !isFreeSpinMode && autoSpins === 0) {
            setTimeout(() => {
                showWinAnimation(apiResult.win);
            }, 1000);
        }
    } else {
        if (!isFreeSpinMode){
            document.getElementById('update_winnings').innerHTML = '0.00';
        }
        
    }

    // Handle free spins
    if (apiResult.triggerFreeSpins && !isFreeSpinMode) {

        storePreFreeSpinState(apiResult);

        freeSpinTriggeredRecently = true;
        
        // Change background image to volcano
        
        // Show free spins overlay
            function delayMs(milliseconds) {
                return new Promise(resolve => setTimeout(resolve, milliseconds));
            }

            async function showImageTemporarily() {
                await delayMs(3500); 
                freeSpinsOverlay.style.display = 'block';  
                document.getElementById('img_top').src = 'volcano.gif'
                audioManager.stopSound(audioManager.sounds.background);
                audioManager.playSound(audioManager.sounds.freeSpin);   // Show image
                await delayMs(4000);     
                startfreespinsoverlay.style.display = 'block'          // Wait 4 seconds
                freeSpinsOverlay.style.display = 'none';      // Hide image
            }

            // Run the async function
            showImageTemporarily();


            async function fetchGifAsBuffer(url) {
                const response = await fetch(url);
                const buffer = await response.arrayBuffer();
                return new Uint8Array(buffer); // omggif needs Uint8Array
            }

            function getGifDuration(buffer) {
                const reader = new GifReader(buffer);
                const frameCount = reader.numFrames();
                let duration = 0;

                for (let i = 0; i < frameCount; i++) {
                const info = {};
                reader.frameInfo(i, info);
                // Delay is in hundredths of a second (1/100 s)
                const delay = info.delay || 10;
                duration += delay * 10; // Convert to milliseconds
                }

                return duration;
            }

            async function onGifFinish(url, callback) {
                // const buffer = await fetchGifAsBuffer(url);
                // const duration = getGifDuration(buffer);
                // console.log(`GIF duration: ${duration}ms`);
                setTimeout(callback, 3500);
            }

            const gifElement = document.getElementById("img_top");
            const gifUrl = gifElement.src;

            onGifFinish(gifUrl, () => {
                if (apiResult.bonusMultiplier == 3) {
                    document.getElementById('img_top').src = 'multipliers/part2/3x.gif';
                } else if (apiResult.bonusMultiplier == 6) {
                    document.getElementById('img_top').src = 'multipliers/part2/6x.gif';
                } else if (apiResult.bonusMultiplier == 9) {
                    document.getElementById('img_top').src = 'multipliers/part2/9x.gif';
                } else if (apiResult.bonusMultiplier == 18) {
                    document.getElementById('img_top').src = 'multipliers/part2/18x.gif';
                } else if (apiResult.bonusMultiplier == 36) {
                    document.getElementById('img_top').src = 'multipliers/part2/36x.gif';
                } else if (apiResult.bonusMultiplier == 72) {
                    document.getElementById('img_top').src = 'multipliers/part2/72x.gif';
                }
                // Add your custom logic here
            });


            isFreeSpinMode = true;
            freeSpinCount = freeSpinCount + 13;
            // bonusMultiplier = result.bonus_multiplier;
            originalBetAmount = stake;


            document.getElementById('freespins_display').style.display = "flex";
            document.getElementById('normalspins_display').style.display = "none";

            // remainingFreeSpinCount += 1
            document.getElementById('remaining_fs_holder').innerHTML = remainingFreeSpinCount;
            document.getElementById('total_fs_holder').innerHTML = freeSpinCount;


            // Update free spins indicator
            // freeSpinsIndicator.style.display = 'block';
            freeSpinsCountElement.textContent = freeSpinCount;
            bonusMultiplierElement.textContent = bonusMultiplier;
            
            
    } 
    else if (apiResult.triggerFreeSpins && isFreeSpinMode) {
        remainingFreeSpinCount += 1;

        // Additional free spins during free spin mode
        setTimeout(() => {
            freeSpinsOverlayImg.style.display = "none";
            freeSpinsOverlayImg2.style.display = "block";
            freeSpinsOverlay.style.display = 'block';
            
            // Hide overlay after 3 seconds
            setTimeout(() => {
                freeSpinsOverlay.style.display = 'none';
                
                // Add more free spins
                freeSpinCount += 13;
                
                // Update displays
                document.getElementById('remaining_fs_holder').innerHTML = remainingFreeSpinCount;
                document.getElementById('total_fs_holder').innerHTML = freeSpinCount;
                
                // Update free spins indicator
                freeSpinsCountElement.textContent = freeSpinCount;
                
                // Continue free spins
                setTimeout(() => {
                    if (!spinning) {
                        spin();
                    }
                }, 1000);
            }, 3000);
        }, 1000);
    }
    else if (isFreeSpinMode) {
        // Already in free spin mode
        remainingFreeSpinCount += 1;
        
        // Update displays
        document.getElementById('remaining_fs_holder').innerHTML = remainingFreeSpinCount;
        
        // Check if free spins are over
        if (remainingFreeSpinCount >= freeSpinCount) {

            function showWinContainer() {
                const el = document.getElementById('win-container');
                el.style.display = 'block'; // Immediately show the element
                // Trigger reflow to ensure transition is applied
                void el.offsetWidth;
                el.classList.add('show');
            }
            

            freeSpinEndedRecently = true
            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            async function run() {
                console.log("Start");
                document.getElementById('display_accumulated_freespin_amount').innerHTML = accumulatedAmountDuringFreespin.toFixed(2);
                document.getElementById('img_top').src = "volcano_eruption.gif"
                await sleep(3000)
                document.getElementById('credits_overlay').style.display = 'block';
                new CoinAnimation();
                setTimeout(showWinContainer, 1000);
                await sleep(9000); // Sleep for 2000 milliseconds (2 seconds)
                document.getElementById('img_top').src = 'bg-top6.gif'
                console.log('Free spins ended, redrawing pre-free spin symbols...')
                // Redraw the symbols from before free spins started
                if (redrawPreFreeSpinSymbols()) {
                    console.log('Successfully restored pre-free spin symbols');
                    highlightWinningSymbols(reels, extractScatterPositions(stoppedReelsPreFreeSpin.reels || reels));
                } else {
                    console.log('Failed to restore pre-free spin symbols, using current reels');
                }
                document.getElementById('credits_overlay').style.display = 'none';
                await sleep(3000)
            }
            run();

            accumulatedAmountDuringFreespin = 0;

            displayBalance(balance)

            console.log("niiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiice")

            

            // End free spins - transition from free spin to background music
            audioManager.stopSound(audioManager.sounds.freeSpin);
            audioManager.playBackgroundMusic();
            

            freeSpinCount = 0;
            remainingFreeSpinCount = 0;
            isFreeSpinMode = false;
            bonusMultiplier = 0;
            originalBetAmount = 0;
            freeSpinsIndicator.style.display = 'none';

            drawWalls()
            
            // Reset displays
            freeSpinsOverlayImg.style.display = "block";
            freeSpinsOverlayImg2.style.display = "none";
            document.getElementById('freespins_display').style.display = "none";
            document.getElementById('normalspins_display').style.display = "flex";
            
            document.getElementById('remaining_fs_holder').innerHTML = 0;
            document.getElementById('total_fs_holder').innerHTML = 0;
            
            // Reset background
            // document.getElementById('img_top').src = 'bg-top6.gif'
        } else {
            // Continue free spins
            setTimeout(() => {
                if (!spinning) {
                    spin();
                }
            }, 1500);
        }
    }

    // Update auto spins
    if (autoSpins > 0 && !isFreeSpinMode) {
        if (autoSpinsStopped) {
            autoSpins = 0;
            updateAutoSpinStatus();
            remainingAutoSpins.innerHTML = ' ';
        }
        else {
            autoSpins--;
            if (autoSpins == 0) {
                autoSpinsStopped = true;
                updateAutoSpinStatus();
                remainingAutoSpins.innerHTML = ``;
            } else {
                remainingAutoSpins.innerHTML = `${autoSpins}`;
                if (autoSpins > 0 && balance >= stake) {
                    setTimeout(() => spin(), 1400);
                }
            }
        }
    }
    else if (!isFreeSpinMode) {
        autoSpinsStopped = true;
        updateAutoSpinStatus();
        remainingAutoSpins.innerHTML = ' ';
    }

    // Inside the spinAnimation callback, after all reels have stopped
    if ((apiResult.winningPositions && apiResult.winningPositions.length > 0) || apiResult.triggerFreeSpins){
        groupWinValuesDisplay(apiResult.winningPositions)
        // Highlight winning symbols after a short delay
        setTimeout(() => {
            if (apiResult.triggerFreeSpins){
                console.log('scatter positions')
                audioManager.playSound(audioManager.sounds.bonusAlarm)
                highlightWinningSymbols(apiResult.reels, extractScatterPositions(apiResult.reels));

                setTimeout(() => {
                    activeAnimations = {};
                    // Restore original drawStoppedReels function if it was overridden
                    if (typeof originalDrawStoppedReels === 'function') {
                        drawStoppedReels = originalDrawStoppedReels;
                    }
                    // Redraw the game to update the display
                    drawGameWithNewSymbols();
                }, 3500);
            } else {
                highlightWinningSymbols(apiResult.reels, apiResult.winningPositions);
            }
            
            
        }, 500);
    }

   
}

// Modify the spinAnimation function to handle waiting for server results
async function spin() {
    removeBonusFrameFromLastReel()
    
    anySymbolConsecutive = false;

    document.getElementById('display_win_amount').style.display = 'none';

    if (spinning || (balance < stake && !isFreeSpinMode)) return;

    // Check if loss limit has been reached
    if (autoSpins > 0 && !isFreeSpinMode) {
        const currentLoss = initialBalance - balance;
        const maxAllowedLoss = lossLimit === Infinity ? Infinity : stake * lossLimit;
        
        if (currentLoss >= maxAllowedLoss && maxAllowedLoss !== Infinity) {
            autoSpinsStopped = true;
            updateAutoSpinStatus();
            remainingAutoSpins.innerHTML = '';
            autoSpins = 0;
            alert(`Auto-spins stopped: Loss limit of ${maxAllowedLoss.toFixed(2)} reached.`);
            return;
        }
    } 
    
    if (stake <= 0 || (stake > balance && !isFreeSpinMode)) {
        alert("Invalid stake amount!");
        return;
    }

    // Stop any active animations by clearing the activeAnimations object
    activeAnimations = {};
    
    // Restore original drawStoppedReels function if it was overridden
    if (typeof originalDrawStoppedReels === 'function') {
        drawStoppedReels = originalDrawStoppedReels;
    }

    // Rotate the spin button image before spinning
    rotateSpinButtonImage();

    // Deduct bet amount if not in free spin mode
    if (!isFreeSpinMode) {
        async function placeAndHandleBet(stake) {
            try {
                const place_bet_response = await placeBet(stake);
                console.log(place_bet_response);
                balance -= stake;
                if (!isFreeSpinMode){
                    displayBalance(balance);
                }
            } catch (error) {
                console.error("Error placing bet:", error);
            }
        }

        await placeAndHandleBet(stake)
    }

    spinning = true;
    featuresButton.disabled = true;

    // Hide win message
    winMessageElement.style.display = 'none';
    if (!isFreeSpinMode){
        document.getElementById('update_winnings').innerHTML = '0.00';
    }

    // Prepare reels for spinning
    for (let i = 0; i < REEL_COUNT; i++) {
        // Reset position
        reels[i].position = 0;
        
        // Set spinning state
        reels[i].isSpinning = true;
        reels[i].lastPosition = 0;
        
        // Generate a full conveyor belt of symbols for smooth scrolling
        const totalSymbols = SYMBOLS_PER_REEL_ARRAY[i];
        reels[i].symbols = [];
        
        // Create a continuous belt of random symbols
        for (let j = 0; j < totalSymbols; j++) {
            const randomIndex = Math.floor(Math.random() * SYMBOLS.length);
            reels[i].symbols.push({
                name: SYMBOLS[randomIndex].name,
                isSpecial: Math.random() < 0.3,
                scale: Math.random() * 0.5 + 1.1
            });
        }
    }

    // Get spin results based on game mode
    let apiResult;
    let animationController = { 
        hasResults: false, 
        results: null
    };






// Enhanced spinAnimation function with additional slowdown for last reel after 4th reel stops
function spinAnimation(callback, initialApiResult) {
    // Whether we're waiting for server results
    let waitingForResults = initialApiResult === null;
    
    // Store initial API result if available
    if (initialApiResult) {
        animationController.hasResults = true;
        animationController.results = initialApiResult;
    }
    
    // Calculate dimensions
    const reelHeight = canvas.height - WALL_THICKNESS.top - WALL_THICKNESS.bottom;
    const symbolHeight = reelHeight / SYMBOLS_PER_REEL;
    
    // Animation configuration
    const spinSpeed = isQuickSpinMode ? 70 : 90; // Pixels per frame
    const stopDelayBetweenReels = isQuickSpinMode ? 300 : 600; // ms between reel stops
    
    const minSpinTime = isQuickSpinMode ? 10 : 1500;
    
    // Animation state variables
    let startTime = null;
    let firstReelStopTime = 0;
    let addedBonusReel = false;
    const reelStopStartTimes = []; // When each reel should start its stopping sequence
    const reelStopTimes = Array(REEL_COUNT).fill(null); // When each reel should be fully stopped

    let consecutiveScatterSymbols = [];
    
    // Check if this is a big win (over 100) to apply special effects to the last reel
    const isBigWin = animationController.results && animationController.results.win > 1;
    
    // Track when the 4th reel stops for additional last reel slowdown
    let fourthReelStoppedTime = null;
    
    // Safety timeout to prevent infinite spinning
    const maxSpinTime = 15000; // 15 seconds max spin time
    
    // Animation function using requestAnimationFrame for smoother animation
    function animate(timestamp) {
        // Check if we now have results that we didn't have before
        if (animationController.hasResults && waitingForResults) {
            console.log("Animation received results, preparing to stop reels");
            waitingForResults = false;
            
            // Start stopping reels immediately when we have results
            firstReelStopTime = timestamp + minSpinTime;
            
            // Calculate stop times for each reel with increasing delays
            for (let i = 0; i < REEL_COUNT; i++) {
                // Only add extra delay to the last reel for big wins
                const extraDelay = (i === REEL_COUNT - 1 && isBigWin) ? 800 : 0;
                reelStopStartTimes[i] = firstReelStopTime + i * stopDelayBetweenReels + extraDelay;
            }
        }
        
        // Initialize start time on first frame
        if (!startTime) {
            startTime = timestamp;
            
            // If we have results from the beginning, calculate when each reel should stop
            if (!waitingForResults) {
                firstReelStopTime = startTime + minSpinTime;
                
                // Calculate stop times for each reel with increasing delays
                for (let i = 0; i < REEL_COUNT; i++) {
                    // Only add extra delay to the last reel for big wins
                    const extraDelay = (i === REEL_COUNT - 1 && isBigWin) ? 800 : 0;
                    reelStopStartTimes[i] = firstReelStopTime + i * stopDelayBetweenReels + extraDelay;
                }
            }
        }
        
        // Calculate elapsed time since animation started
        const elapsed = timestamp - startTime;
        
        // Safety check - force stop after max spin time
        if (elapsed > maxSpinTime) {
            console.warn("Spin timeout reached - forcing stop");
            for (let i = 0; i < REEL_COUNT; i++) {
                reels[i].isSpinning = false;
            }
            
            // Draw final state
            drawGame();
            
            // Reset spin button image
            resetSpinButtonImage();
            
            // Enable features button
            featuresButton.disabled = false;
            
            spinning = false;
            
            // Call the callback function
            if (callback) callback();
            
            return; // Exit animation loop
        }
        
        // Check if the 4th reel (index 3) has stopped and record the time
        if (!reels[3].isSpinning && fourthReelStoppedTime === null) {
            fourthReelStoppedTime = timestamp;
            console.log("4th reel stopped, applying additional slowdown to last reel");
        }
        
        // Update each reel
        let allReelsStopped = true;
        
        for (let i = 0; i < REEL_COUNT; i++) {
            if (!reels[0].isSpinning && !addedBonusReel && !waitingForResults && apiResult && !apiResult.triggerFreeSpins && apiResult.win >= 20 && checkConsecutiveSymbols(apiResult.reels)){
            // if (!reels[1].isSpinning && !addedBonusReel && !waitingForResults && apiResult && !apiResult.triggerFreeSpins){
                addBonusFrameToLastReel();
                audioManager.playSound(audioManager.sounds.reelSpeedUp)
                addedBonusReel = true;
            }

            if (!reels[i].isSpinning) continue;
            
            allReelsStopped = false;
            
            // If we have results and it's time to start stopping this reel
            if (!waitingForResults && reelStopTimes[i] === null && timestamp >= reelStopStartTimes[i]) {
                // Set the time when this reel should be fully stopped
                // Only extend stopping time for the last reel on big wins
                const stopDuration = (i === REEL_COUNT - 1 && isBigWin) ? symbolHeight * 5 : symbolHeight * 1;
                reelStopTimes[i] = timestamp + stopDuration;
                
                // Play stop sound if enabled
                if (soundEffectsEnabled) {
                    const stopSound = new Audio("sounds/SE_Spinstop.mp3");
                    stopSound.volume = 0.9;
                    stopSound.play().catch(e => console.log("Audio play failed:", e));
                }
            }
            
            // Calculate how far this reel should have traveled
            let distance;
            
            // If this reel is in stopping sequence
            if (reelStopTimes[i] !== null) {
                // Calculate how much time is left until stop
                const timeUntilStop = reelStopTimes[i] - timestamp;
                
                if (timeUntilStop <= 0) {
                    // Reel has stopped
                    reels[i].isSpinning = false;
                    
                    // Position the reel exactly where it should be
                    reels[i].position = 0;
                    
                    // Set the final symbols if available
                    if (animationController.results && 
                        animationController.results.reels && 
                        animationController.results.reels[i]) {

                        reels[i].finalSymbols = animationController.results.reels[i];

                        const hasScatterInFinal = reels[i].finalSymbols.some(symbol => symbol.name.toLowerCase() === "scatter");
                        consecutiveScatterSymbols.push(hasScatterInFinal)
                        const hasConsecutiveScatters = consecutiveScatterSymbols.every(item => item === true)
                        if (hasConsecutiveScatters && soundEffectsEnabled){
                            const scatterSound = new Audio(`sounds/SE_Base_Hit_0${i + 1}.mp3`);
                            scatterSound.volume = 0.9;
                            scatterSoundcurrentTime = 0;
                            scatterSound.play().catch(e => console.log("Audio play failed:", e));
                        } 

                        if (i == 4){
                            consecutiveScatterSymbols = []
                        }
                    }
                    
                    continue;
                }
                
                // Deceleration effect - ease out as we approach the stop time
                const progress = 1 - timeUntilStop / (reelStopTimes[i] - reelStopStartTimes[i]);
                const easeOutFactor = 1 - Math.pow(1 - progress, 3);
                
                // Calculate distance with deceleration
                const totalSpinDistance = symbolHeight * SYMBOLS_PER_REEL * 2;
                
                // Apply special slowdown effect ONLY for the last reel if this is a big win
                if (i === REEL_COUNT - 1 && isBigWin) {
                    // Check if 4th reel has stopped for additional slowdown
                    const fourthReelStopped = fourthReelStoppedTime !== null;
                    
                    let slowdownFactor;
                    
                    if (fourthReelStopped) {
                        // EXTREME slowdown after 4th reel stops - crawl to a stop
                        // Start with 30% speed and slow down to just 8% for maximum drama
                        slowdownFactor = 0.20 - (progress * 0.15);
                        
                        // Apply an ultra-dramatic slowdown in the final phase
                        const ultraSlowdown = progress > 0.5 ? Math.pow(1 - progress, 0.2) * 0.2 + 0.08 : slowdownFactor;
                        
                        distance = totalSpinDistance * (1 - easeOutFactor) * ultraSlowdown;
                        
                        // Add very pronounced oscillation and hesitation effects
                        if (progress > 0.3) {
                            // Intense oscillation that simulates the reel "fighting" to stop
                            const oscillationIntensity = Math.sin(progress * Math.PI) * 1.5;
                            const oscillation = Math.sin(progress * 20) * oscillationIntensity * (1 - progress);
                            distance += oscillation;
                            
                            // Add dramatic "hesitation" effect - like the reel is struggling
                            if (progress > 0.7) {
                                const hesitation = Math.sin(progress * 30) * 0.8 * (1 - progress);
                                distance += hesitation;
                            }
                            
                            // Add random "stutter" for maximum tension
                            if (progress > 0.85) {
                                const stutter = (Math.random() - 0.5) * 0.7 * (1 - progress);
                                distance += stutter;
                            }
                        }
                    } else {
                        // Normal big win slowdown before 4th reel stops
                        slowdownFactor = 0.5 - (progress * 0.35);
                        const finalSlowdown = progress > 0.6 ? Math.pow(1 - progress, 0.3) * 0.4 + 0.15 : slowdownFactor;
                        
                        distance = totalSpinDistance * (1 - easeOutFactor) * finalSlowdown;
                        
                        // Moderate oscillation before extreme slowdown
                        if (progress > 0.4) {
                            const oscillationIntensity = Math.sin(progress * Math.PI) * 1.0;
                            const oscillation = Math.sin(progress * 12) * oscillationIntensity * (1 - progress);
                            distance += oscillation;
                        }
                    }
                } else {
                    // Normal stopping behavior for all other reels
                    distance = totalSpinDistance * (1 - easeOutFactor);
                }
                
                // Add subtle oscillation for natural deceleration (all reels)
                if (progress > 0.85 && i !== REEL_COUNT - 1) {
                    const oscillation = Math.sin(progress * 2) * 0.3 * (1 - progress);
                    distance += oscillation;
                }

            } else {
                // Regular spinning - constant speed for all reels
                // But slow down the last reel during spinning if 4th reel has stopped and it's a big win
                if (i === REEL_COUNT - 1 && isBigWin && fourthReelStoppedTime !== null && reelStopTimes[i] === null) {
                    // Slow down the spinning speed of the last reel after 4th reel stops
                    distance = (elapsed / 16.67) * spinSpeed * 0.3; // 60% of normal spinning speed
                } else {
                    distance = (elapsed / 16.67) * spinSpeed;
                }
            }

            
            // Smooth conveyor belt-like motion for the reels with downward flow
            const previousPosition = reels[i].position || 0;
            const totalHeight = symbolHeight * SYMBOLS_PER_REEL_ARRAY[i];
            const newPosition = distance % totalHeight;
            
            // Generate new random symbols continuously as the reel spins
            const prevSymbolIndex = Math.floor(previousPosition / symbolHeight);
            const newSymbolIndex = Math.floor(newPosition / symbolHeight);
            
            const totalSymbols = SYMBOLS_PER_REEL_ARRAY[i];
            
            // Always replace the top 3 symbols (those about to enter the view)
            for (let k = 0; k < 3; k++) {
                const topSymbolIndex = (newSymbolIndex - SYMBOLS_PER_REEL - k + totalSymbols) % totalSymbols;
                
                const randomIndex = Math.floor(Math.random() * SYMBOLS.length);
                reels[i].symbols[topSymbolIndex] = {
                    name: SYMBOLS[randomIndex].name,
                    isSpecial: Math.random() < 0.3,
                    scale: Math.random() * 0.5 + 1.1
                };
            }
            
            reels[i].position = newPosition;
            
            // Store the final symbols that should appear when the reel stops
            if (animationController.results && 
                animationController.results.reels && 
                animationController.results.reels[i] && 
                !reels[i].finalSymbols) {
                reels[i].finalSymbols = animationController.results.reels[i];
            }
        }
        
        // Draw the current state
        drawGame();
        
        // Continue animation if any reels are still spinning
        if (!allReelsStopped) {
            requestAnimationFrame(animate);
        } else {
            // All reels have stopped
            spinning = false;
            
            // Reset spin button image
            resetSpinButtonImage();
            
            // Enable features button
            featuresButton.disabled = false;
            
            // Call the callback function
            if (callback) callback();
            
            // Handle spin completion if we have results
            if (animationController.results) {
                handleSpinCompletion(animationController.results);
            }
        }
    }
    
    // Start the animation
    requestAnimationFrame(animate);
}


    // Function to update the animation with results
    function updateSpinningReelsWithResults(results) {
        console.log("Updating spinning reels with results:", results);
        animationController.hasResults = true;
        animationController.results = results;
    }
    
    if (gameMode.mode === 'live') {
        // In live mode, fetch results from server
        showLoadingIndicator(); // Show loading indicator if server takes too long

        const payload = {
            client_id: gameInfo.client_id,
            game_id: gameInfo.game_id,
            player_id: playerInfo.id,
            bet_id: lastPlacedBetData.bet_id,
            bet_amount: isFreeSpinMode ? 0 : stake,
            is_free_spin: isFreeSpinMode,
            free_spin_count: freeSpinCount,
            bonus_multiplier: bonusMultiplier,
            original_bet_amount: isFreeSpinMode ? originalBetAmount : 0
        };
        
        try {
            // Start spinning animation while waiting for server response
            const spinPromise = new Promise(resolve => {
                spinAnimation(() => {
                    // This callback won't be called until we have results
                    resolve();
                }, null); // Pass null to indicate we're waiting for results
            });
            
            // Fetch results from server
            apiResult = await fetchSpinResultsFromServer(payload);
            console.log("API returned results:", apiResult);
            hideLoadingIndicator();
            
            // Update the spinning animation with the actual results
            updateSpinningReelsWithResults(apiResult);
            
            // Wait for spinning animation to complete
            await spinPromise;
        } catch (error) {
            console.error('Error in live mode spin:', error);
            hideLoadingIndicator();
            
            // Fallback to local generation
            const mockResults = generateMockResults();
            const winResult = calculateWinAmount(mockResults, isFreeSpinMode, bonusMultiplier);
            apiResult = {
                reels: mockResults.reels,
                win: winResult.amount,
                winningPositions: winResult.positions,
                triggerFreeSpins: mockResults.triggerFreeSpins
            };
            
            // Update with fallback results
            updateSpinningReelsWithResults(apiResult);
        }
    } else {
        // In demo mode, generate results locally
        const mockResults = generateMockResults();
        const winResult = calculateWinAmount(mockResults, isFreeSpinMode, bonusMultiplier);
        apiResult = {
            reels: mockResults.reels,
            win: winResult.amount,
            winningPositions: winResult.positions,
            triggerFreeSpins: mockResults.triggerFreeSpins
        };
        
        // Start spin animation with local results
        spinAnimation(() => {
            handleSpinCompletion(apiResult);
        }, apiResult);
    }
}


// Add a function to toggle between demo and live modes
function toggleGameMode() {
    gameMode.mode = gameMode.mode === 'demo' ? 'live' : 'demo';
    
    // Update UI to show current mode
    const modeText = document.querySelector('.text-white.text-center span');
    if (modeText) {
        modeText.textContent = gameMode.mode.toUpperCase() + ' GAME';
    }
    
    console.log('Game mode switched to:', gameMode.mode);
}

// Add a button to toggle game mode in the settings overlay
// Add this to the settingsOverlay div, inside the first div of the overlay-content
// const settingsContent = document.querySelector('#settingsOverlay .overlay-content > div');
// if (settingsContent) {
//     const modeToggleDiv = document.createElement('div');
//     modeToggleDiv.className = 'd-flex justify-content-center my-4';
//     modeToggleDiv.innerHTML = `
//         <button id="toggleModeButton" class="btn btn-gold px-4 py-2">
//             Switch to LIVE Mode
//         </button>
//     `;
//     settingsContent.appendChild(modeToggleDiv);
    
//     // Add event listener to the button
//     document.getElementById('toggleModeButton').addEventListener('click', function() {
//         toggleGameMode();
//         this.textContent = `Switch to ${gameMode.mode === 'demo' ? 'LIVE' : 'DEMO'} Mode`;
//         settingsOverlay.style.display = 'none';
//     });
// }

    // Initialize loading screen
    initLoading();
    
    // Preload images
    preloadImages();
    preloadWildFrames();

    

    // New variables
    
    // Inactivity timer implementation
    let inactivityTimeout = null;
    let lastActivityTime = Date.now();
    const INACTIVITY_LIMIT = 5 * 60 * 1000; // 5 minutes in milliseconds
    
    // Function to show inactivity overlay
    function showInactivityOverlay() {
        const inactivityOverlay = document.getElementById('inactivityOverlay');
        if (inactivityOverlay) {
            inactivityOverlay.style.display = 'flex';
        }
    }
    
    // Function to reset the inactivity timer
    function resetInactivityTimer() {
        lastActivityTime = Date.now();
        if (inactivityTimeout) {
            clearTimeout(inactivityTimeout);
        }
        
        inactivityTimeout = setTimeout(() => {
            // Check if 5 minutes have passed since last activity
            const currentTime = Date.now();
            const timeSinceLastActivity = currentTime - lastActivityTime;
            
            if (timeSinceLastActivity >= INACTIVITY_LIMIT) {
                showInactivityOverlay();
            }
        }, INACTIVITY_LIMIT);
    }
    
    // Function to reload the page
    function reloadPage() {
        window.location.reload();
    }
    
    // Add event listeners for user activity
    document.addEventListener('mousemove', resetInactivityTimer);
    document.addEventListener('mousedown', resetInactivityTimer);
    document.addEventListener('keypress', resetInactivityTimer);
    document.addEventListener('touchstart', resetInactivityTimer);
    document.addEventListener('touchmove', resetInactivityTimer);
    document.addEventListener('scroll', resetInactivityTimer);
    
    // Initialize inactivity timer when the page loads
    document.addEventListener('DOMContentLoaded', () => {
        resetInactivityTimer();
        
        // Add event listener for reload button
        const reloadButton = document.getElementById('reloadButton');
        if (reloadButton) {
            reloadButton.addEventListener('click', reloadPage);
        }
    });
    
    // Also check for visibility change (tab change)
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
            // Reset timer when the tab becomes visible again
            resetInactivityTimer();
        } else {
            // When tab is hidden, start counting inactivity
            lastActivityTime = Date.now();
        }
    });
</script>

<!-- Inactivity Overlay -->
<div id="inactivityOverlay" style="display: none !important;">
    <div>
        <h2>Session Timeout</h2>
        <p>Your session has timed out due to inactivity.</p>
        <p>Please reload the game to continue playing.</p>
        <button id="reloadButton">Reload Game</button>
    </div>
</div>
</body>
</html>

